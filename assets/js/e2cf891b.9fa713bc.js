"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[2233],{92870:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"visionary-render/tools/geometry-operators","title":"Geometry Operators","description":"The Geometry Operators provide a way to post-process meshes imported into Visionary Render. They are shown in the Properties window when the following node types are selected:","source":"@site/docs/visionary-render/tools/geometry-operators.mdx","sourceDirName":"visionary-render/tools","slug":"/visionary-render/tools/geometry-operators","permalink":"/visionary-render/tools/geometry-operators","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render/tools/geometry-operators.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"visionaryRenderSidebar","previous":{"title":"Automatic Change Recorder","permalink":"/visionary-render/tools/automatic-change-recorder"},"next":{"title":"Manipulators","permalink":"/visionary-render/tools/manipulators"}}');var r=s(74848),i=s(28453);const o={},a="Geometry Operators",h={},l=[{value:"Generate Normals",id:"generate-normals",level:2},{value:"Generate Tangents",id:"generate-tangents",level:2},{value:"Generate UVs",id:"generate-uvs",level:2},{value:"Tessellate",id:"tessellate",level:2},{value:"Weld",id:"weld",level:2},{value:"Sort Vertices",id:"sort-vertices",level:2},{value:"Invert Surfaces",id:"invert-surfaces",level:2},{value:"Invert Normals",id:"invert-normals",level:2},{value:"Explode",id:"explode",level:2},{value:"Merge",id:"merge",level:2},{value:"Prune",id:"prune",level:2},{value:"Sieve",id:"sieve",level:2},{value:"Recentre",id:"recentre",level:2},{value:"Transform Mesh",id:"transform-mesh",level:2},{value:"Optimise Models",id:"optimise-models",level:2}];function d(e){const t={admonition:"admonition",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"geometry-operators",children:"Geometry Operators"})}),"\n",(0,r.jsx)(t.p,{children:"The Geometry Operators provide a way to post-process meshes imported into Visionary Render. They are shown in the Properties window when the following node types are selected:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Assembly"}),"\n",(0,r.jsx)(t.li,{children:"Visual"}),"\n",(0,r.jsx)(t.li,{children:"Library"}),"\n",(0,r.jsx)(t.li,{children:"Model"}),"\n",(0,r.jsx)(t.li,{children:"GeoGroup"}),"\n",(0,r.jsx)(t.li,{children:"Mesh"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:s(54238).A+"",width:"427",height:"429"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Button"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Settings"}),(0,r.jsxs)(t.td,{children:["Show configuration options for a geometry operator. The default values of these settings can be changed in ",(0,r.jsx)(t.strong,{children:"Settings"})," > ",(0,r.jsx)(t.strong,{children:"Tools"})," > ",(0,r.jsx)(t.strong,{children:"Mesh"}),"."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Apply"}),(0,r.jsx)(t.td,{children:"Traverse down the tree from the selected node and apply a geometry operator to each mesh encountered."})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"generate-normals",children:"Generate Normals"}),"\n",(0,r.jsx)(t.p,{children:"The Generate Normals operator calculates the normal vectors for each vertex of a mesh."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Smoothing Threshold"})," ",(0,r.jsx)(t.em,{children:"[default: 55.0]"})," \u2013 the smoothing threshold defines the threshold angle (in degrees) between polygonal edges after which the vertex normal will not be averaged with the surrounding normals. Modifying this angle can result in the faces being lit as individual surfaces, creating a faceted appearance to the mesh surface. An example of this can be seen below."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:s(23223).A+"",width:"977",height:"620"})}),"\n",(0,r.jsx)(t.p,{children:"An example of the effect of the smoothing threshold setting on the \u2018Generate Normals\u2019 operator. The sphere on the left has a smoothing threshold of 35 degrees whilst the sphere on the right has a smoothing threshold of 5 degrees."}),"\n",(0,r.jsx)(t.admonition,{type:"caution",children:(0,r.jsx)(t.p,{children:"If the mesh has existing normals these will be replaced."})}),"\n",(0,r.jsx)(t.h2,{id:"generate-tangents",children:"Generate Tangents"}),"\n",(0,r.jsx)(t.p,{children:"The Generate Tangents operator calculates the tangent vectors for each vertex on a mesh. For this operator to act, the mesh must have normals associated with it."}),"\n",(0,r.jsx)(t.h2,{id:"generate-uvs",children:"Generate UVs"}),"\n",(0,r.jsx)(t.p,{children:"The Generate UVs operator calculates texture coordinates for each vertex on a mesh. For a mesh to be texture mapped it must have texture (UV) coordinates associated with each vertex."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Mapping Mode"})," ",(0,r.jsx)(t.em,{children:"[default: Plane]"})," \u2013 there are 5 types of mapping that can be applied when generating texture coordinates: Plane, Box, Cylinder, Sphere and Linear. Each mode tends to be suited to certain types of shape."]}),"\n"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Image"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{src:s(47617).A+"",width:"404",height:"384"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.strong,{children:"Plane"}),(0,r.jsx)("br",{}),"Generates texture coordinates by projecting a plane onto the mesh."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{src:s(61980).A+"",width:"413",height:"418"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.strong,{children:"Box"}),(0,r.jsx)("br",{}),"Generates texture coordinates by projecting a cube onto the mesh."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{src:s(24685).A+"",width:"413",height:"478"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.strong,{children:"Cylinder"}),(0,r.jsx)("br",{}),"Generates texture coordinates by projecting a cylinder onto the mesh."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{src:s(43528).A+"",width:"389",height:"404"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.strong,{children:"Sphere"}),(0,r.jsx)("br",{}),"Generates texture coordinates by projecting a sphere onto the mesh."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{src:s(10812).A+"",width:"413",height:"428"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.strong,{children:"Linear"}),(0,r.jsx)("br",{}),"Generates texture coordinates by projecting a line onto the mesh. This can be used to apply gradient textures to geometry."]})]})]})]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Mapping Axis"})," ",(0,r.jsx)(t.em,{children:"[default: X]"})," \u2013 the Mapping Axis setting allows you to specify which of the major axes (x, y, or z) the mapping shapes are orientated along. The images below show the effect that this has on various cubes."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:s(26256).A+"",width:"1041",height:"564"})}),"\n",(0,r.jsx)(t.p,{children:"A cube with a Plane mapping orientated along the x, y, and z axes."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:s(94389).A+"",width:"1012",height:"544"})}),"\n",(0,r.jsx)(t.p,{children:"A cube with a Sphere mapping orientated along the x, y, and z axes."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"UV Offset"})," ",(0,r.jsx)(t.em,{children:"[default: (0.0, 0.0)]"})," \u2013 the UV offset parameter allows you to offset the texture coordinates from their default position. This can be used to adjust the position of textures on a mesh. An example of this setting being used in practice can be seen below."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:s(50009).A+"",width:"693",height:"463"})}),"\n",(0,r.jsx)(t.p,{children:"An example of two cubes with a Box mapped texture coordinates applied them. The left cube has no offset specified, whilst the right cube has an offset of 0.1 on the horizontal axis and 0.1 on the vertical."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"UV Scale"})," ",(0,r.jsx)(t.em,{children:"[default: (1.0, 1.0)]"})," \u2013 the UV scale parameter allows you to specify the size of the texture that is mapped to the mesh. If the WrapU and WrapV texture properties are set to GL_REPEAT and the scale of the texture is greater than 1, the texture will tile across the surfaces of the mesh. An example of this can be seen in the image below."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:s(62015).A+"",width:"673",height:"454"})}),"\n",(0,r.jsx)(t.p,{children:"An example of two cubes with Box mapped texture coordinates applied to them. The left cube has a UV scale of 0, 0 applied, whilst the right has a UV scale of 3, 3 applied."}),"\n",(0,r.jsx)(t.h2,{id:"tessellate",children:"Tessellate"}),"\n",(0,r.jsx)(t.p,{children:"The Tessellate operator re-tessellates a selected mesh according to its Max Edge Length parameter. When modifying the mesh topology, the tessellate operator will interpolate and create all the vertex attributes associated with the mesh."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Max Edge Length"})," ",(0,r.jsx)(t.em,{children:"[default: 0.05]"})," \u2013 specifies the maximum edge length of a polygon before it is split into a smaller triangle. An example of the tessellate operator acting on a coarsely meshed sphere can be seen below."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:s(88851).A+"",width:"951",height:"599"})}),"\n",(0,r.jsx)(t.p,{children:"An example of the sphere that has been tessellated with the tessellate operator. The original sphere is shown on the left and the new sphere, tessellated with a Maximum Edge Length of 0.01, is shown on the right."}),"\n",(0,r.jsx)(t.h2,{id:"weld",children:"Weld"}),"\n",(0,r.jsx)(t.p,{children:"The Weld operator combines (or welds) vertices that are close to each other in a mesh. This operation can be useful when optimising the performance of a scene as it will reduce the number of vertices within the mesh."}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsx)(t.p,{children:"Since the weld operation modifies the topology of the mesh, new normals should be generated after the operation has been performed."})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Tolerance"})," ",(0,r.jsx)(t.em,{children:"[default: 0.003]"})," \u2013 vertices within the specified tolerance value (in metres) will be combined. For best results and to prevent the weld operator being too destructive the value specified should be set to only include vertices that share polygonal edges. This value will vary from mesh to mesh."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"sort-vertices",children:"Sort Vertices"}),"\n",(0,r.jsx)(t.p,{children:"The Sort Vertices operator optimises indexed triangle lists within a mesh to reduce the number of cache misses that occur when looking for vertices on the graphics card. This operation can provide significant performance gains when rendering large meshes. For best results, a weld operation should be performed as a prerequisite to this optimisation."}),"\n",(0,r.jsx)(t.h2,{id:"invert-surfaces",children:"Invert Surfaces"}),"\n",(0,r.jsx)(t.p,{children:"The Invert Surfaces operator inverts the surfaces of a mesh by reversing the winding of the polygons. Since this operator invalidates the vertex normals it will automatically recalculate the normals until the operation has been completed."}),"\n",(0,r.jsx)(t.h2,{id:"invert-normals",children:"Invert Normals"}),"\n",(0,r.jsx)(t.p,{children:"The Invert Normals operator inverts the direction of a mesh\u2019s normals without affecting polygon winding order."}),"\n",(0,r.jsx)(t.h2,{id:"explode",children:"Explode"}),"\n",(0,r.jsx)(t.p,{children:"The Explode operator divides a mesh into individual nodes based on which parts of the mesh are connected."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Tolerance"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: 0.003]"}),"\xa0\u2013 how much space can be between the mesh before it is identified as a separate component."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Mode"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: Structure]"}),"\xa0\u2013 how the model is treated when performing the modifier.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Structure"}),"\xa0\u2013 examine each node in the hierarchy separately, without considering that meshes from separate GeoGroups may be intersecting."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Connected"}),"\xa0\u2013 examine the entire model as a single mesh. Allowing for smaller meshes, that are part of one big mesh, to not be needlessly separated. When this mode is selected, previous options are unavailable as they are not used as part of this option. Applying this option will explode the model into multiple models, based on what parts are attached. Any nodes referencing this model will be duplicated, to produce a node for each of the newly generated models. This action cannot be applied to models containing LODs."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Explode Meshes"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: true]"}),"\xa0\u2013 tells the modifier that you wish to divide the mesh up into multiple meshes, based on what is connected. This produce a mesh for each separate component of the mesh, adding them to the tree as a sibling to the original."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Explode GeoGroups"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: true]"}),"\xa0\u2013 tells the modifier to separate the model's meshes into their own geogroup nodes. This will result in each geogroup in the model containing a single unique mesh."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Explode Models"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: true]"}),"\xa0\u2013 tells the modifier to separate the model's geogroups into their own model modes. This will result in each of the produced models only containing a single unique geogroup. As this divides a model into multiple models; any node that references the original model will be duplicated, to produce a node for each of the newly generated models. This action cannot be applied to models containing LODs."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"merge",children:"Merge"}),"\n",(0,r.jsx)(t.p,{children:"The Merge operator merges all the children of a selected Assembly into a single Model node."}),"\n",(0,r.jsx)(t.h2,{id:"prune",children:"Prune"}),"\n",(0,r.jsx)(t.p,{children:"The Prune operator removes parts of the model based on which parts of the mesh are connected."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Mode"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: Structure]"}),"\xa0\u2013how the model is treated when performing the modifier.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Structure"}),"\xa0\u2013 examine each mesh node independently. Not considering that separate mesh node may intersect."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Connected"}),"\xa0\u2013 examine the entire model as a single mesh. Allowing for intersecting meshes to be treated as a single entity."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Fraction"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: 0.1, range: (0.0, 1.0)]"}),"\xa0\u2013 the portion of the model that is to be pruned."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Centre Bias"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: 0.0, range: (-2.0, 2.0)]"}),"\xa0\u2013 the bias applied when determining which parts of the model to remove. A negative value will try to remove mesh data from the edge of the model, whereas a positive value will try to remove mesh data from the centre of the model."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Tolerance"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: 0.003]"}),"\xa0\u2013 how much space can be between the mesh before it is identified as a separate component."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"sieve",children:"Sieve"}),"\n",(0,r.jsx)(t.p,{children:"The Sieve operator removes parts of the model based on which parts of the mesh are connected and their overall size."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Mode"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: Structure]"}),"\xa0\u2013 how the model is treated when performing the modifier.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Structure"}),"\xa0\u2013 examine each mesh node independently. Not considering that separate mesh node may intersect."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Connected"}),"\xa0\u2013 examine the entire model as a single mesh. Allowing for intersecting meshes to be treated as a single entity."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Size Limit"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: 0.025]"}),"\xa0\u2013 the maximum size of what should be removed from the model. Models that have a dimension exceeding this value will be retained."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Tolerance"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: 0.003]"}),"\xa0\u2013 how much space can be between the mesh before it is identified as a separate component."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"recentre",children:"Recentre"}),"\n",(0,r.jsx)(t.p,{children:"The Recentre operator recentres the mesh based on the values provided. Any assemblies that reference this mesh, if they are the first child visual, will have the inverse transform applied, to not impact the visual state of the scene."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"New Origin"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: (0.5, 0.5, 0.5)]"}),"\xa0\u2013 the desired centre point of the model. If relative\xa0the origin will be relative to the bounding box of the model, with (0.5, 0.5, 0.5) being the centre of the model. If not relative\xa0the origin will be an absolute position."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Relative To Bounds"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: true]"}),"\xa0",(0,r.jsx)(t.em,{children:"\u2013"})," (see above)"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"transform-mesh",children:"Transform Mesh"}),"\n",(0,r.jsx)(t.p,{children:"The Transform Mesh operator will transform the mesh vertex properties based on the values provided."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Translation"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: (0.0, 0.0, 0.0)]"}),"\xa0\u2013 the displacement to be applied to the model."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Rotation"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: (0.0, 0.0, 0.0)]"}),"\xa0\u2013 the rotation to be applied to the model."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Scale"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: (1.0, 1.0, 1.0)]"}),"\xa0\u2013 the scale factor to be applied to the model."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Transform Visuals"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: true]"}),"\xa0\u2013 tells the modifier that assemblies which reference this mesh, if they are the first child visual, will have the inverse transform applied, to not impact the visual state of the scene."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Adjust Cull Face"}),"\xa0",(0,r.jsx)(t.em,{children:"[default: true]"}),"\xa0\u2013 tells the modifier to invert the cull face of the model, in the case that the scale transform is negative."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"optimise-models",children:"Optimise Models"}),"\n",(0,r.jsx)(t.p,{children:"The Optimise Models operator permits various common optimisations to be automatically applied to your models."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Merge GeoGroups"})," ",(0,r.jsx)(t.em,{children:"[default: true]"})," \u2013 some models can contain thousands of GeoGroups. This option merges all the GeoGroups that use the same material into a single GeoGroup. Models are unaffected by the merges and can be moved and copied as normal. The only time that it might not be desirable to merge meshes and GeoGroups is when they need to be copied, deleted, or moved within models."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Vertex Sort"})," ",(0,r.jsx)(t.em,{children:"[default: true]"})," \u2013 this option orders the vertices in a mesh so that they are grouped according to use. This results in more efficient memory usage."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Pack Meshes"})," ",(0,r.jsx)(t.em,{children:"[default: true]"})," \u2013 Each model is made up of one or more GeoGroups and each GeoGroup is made up of one or more meshes. When some models are imported they have many meshes in each GeoGroup. The worst case is when each triangle in a model has its own mesh. This can lead to hundreds \u2013 even thousands \u2013 of meshes in each GeoGroup. The problem with this is that that there is a certain overhead for processing each mesh. For a GeoGroup with many meshes the processing time can be much larger than the time to process the actual geometry in the meshes. This option packs your meshes into a far smaller number of meshes, thus removing any large overhead. It is particularly useful when each triangle of a GeoGroup has its own mesh."]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},50009:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/box-mapping-9f80a236433187303ab76569fe736428.png"},61980:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/box-82d9473c84fb69c0c7bf2f4279323b10.png"},24685:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/cylinder-dd129500d4e3f339f962bb7c70bca7e3.png"},10812:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/linear-864bba02c85199399f849c7c5652cd44.png"},23223:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/normals-dcf1e36cf06c8e6744476a65039f557d.png"},54238:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/overview-2e338847213c65e271801ba912724f3d.png"},26256:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/plane-mapping-39d4bdd34dbd94328872140a0e7fd0ac.png"},47617:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/plane-7682c21acef37cc6592a5cab9251a24e.png"},94389:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/sphere-mapping-a3a8e288c047169313f40fc209bcdee6.png"},43528:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/sphere-0d9d82e435bebfaf38cf3f0ac13229b6.png"},88851:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/tessellate-8ae8b49690cae7efda084c1f7b06637c.png"},62015:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/uv-scale-5d4612445027e75bea44d854d5f86c8f.png"},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var n=s(96540);const r={},i=n.createContext(r);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);