"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[6871],{59863:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"visionary-render-programming/reference/c-api/modules/vrexchange","title":"VR Exchange","description":"VR Exchange API functions. This API is used to directly interact with other installed importer and exporter plugins.","source":"@site/docs/visionary-render-programming/reference/c-api/modules/vrexchange.mdx","sourceDirName":"visionary-render-programming/reference/c-api/modules","slug":"/visionary-render-programming/reference/c-api/modules/vrexchange","permalink":"/visionary-render-programming/reference/c-api/modules/vrexchange","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/c-api/modules/vrexchange.mdx","tags":[],"version":"current","frontMatter":{"title":"VR Exchange","summary":"VR Exchange API functions."},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Settings","permalink":"/visionary-render-programming/reference/c-api/modules/settings"},"next":{"title":"vrtree_cpp","permalink":"/visionary-render-programming/reference/c-api/namespaces/vrtree-cpp"}}');var s=r(74848),t=r(28453);const o={title:"VR Exchange",summary:"VR Exchange API functions."},c="VR Exchange",d={},a=[{value:"Functions",id:"functions",level:2},{value:"Functions Documentation",id:"functions-documentation",level:2},{value:"VRXExport",id:"vrxexport",level:3},{value:"VRXGetAPIVersionMajor",id:"vrxgetapiversionmajor",level:3},{value:"VRXGetAPIVersionMinor",id:"vrxgetapiversionminor",level:3},{value:"VRXImport",id:"vrximport",level:3},{value:"VRXImportAndMerge",id:"vrximportandmerge",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"vr-exchange",children:"VR Exchange"})}),"\n",(0,s.jsx)(n.p,{children:"VR Exchange API functions. This API is used to directly interact with other installed importer and exporter plugins."}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Name"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uint32_t"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrxexport",children:"VRXExport"})}),"(const char * file, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," scenes, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," libs, const char * exporterName)",(0,s.jsx)("br",{}),"Saves the specified scenes and libraries nodes to the specified file."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrxgetapiversionmajor",children:"VRXGetAPIVersionMajor"})}),"(void )",(0,s.jsx)("br",{}),"Gets the VRExchange API Major version."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrxgetapiversionminor",children:"VRXGetAPIVersionMinor"})}),"(void )",(0,s.jsx)("br",{}),"Gets the VRExchange API Minor version."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uint32_t"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrximport",children:"VRXImport"})}),"(const char * file, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," scenes, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," libs, const char * importerName)",(0,s.jsx)("br",{}),"Imports the specified file onto the specified scenes and libraries nodes."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"uint32_t"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrximportandmerge",children:"VRXImportAndMerge"})}),"(const char * file, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," scenes, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," libs, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," mergeOptions, const char * importerName)",(0,s.jsx)("br",{}),"Imports and merges the specified file onto the specified scenes and libraries nodes utilising the merge options to append the import data."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"functions-documentation",children:"Functions Documentation"}),"\n",(0,s.jsx)(n.h3,{id:"vrxexport",children:"VRXExport"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"uint32_t VRXExport(\r\n    const char * file,\r\n    HNode scenes,\r\n    HNode libs,\r\n    const char * exporterName\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Saves the specified scenes and libraries nodes to the specified file."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"file"})," The file to export to"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"scenes"})," The root node containing assemblies (e.g. scenes root)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"libs"})," The root node containing library assets (e.g. libraries root)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"exporterName"})," Hint to specify the name of the exporter plugin to use. If not specified (null), attempts to determine a suitable exporter using the file parameter's file extension"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": 1 if the export is successful, otherwise 0"]}),"\n",(0,s.jsx)(n.h3,{id:"vrxgetapiversionmajor",children:"VRXGetAPIVersionMajor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int VRXGetAPIVersionMajor(\r\n    void \r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Gets the VRExchange API Major version."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": major version"]}),"\n",(0,s.jsx)(n.p,{children:"This version represents backward compatibility. It should be checked when loading the library, against an expected value. If it is not what is expected, the API may not function according to the expectations of the program using it."}),"\n",(0,s.jsx)(n.h3,{id:"vrxgetapiversionminor",children:"VRXGetAPIVersionMinor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int VRXGetAPIVersionMinor(\r\n    void \r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Gets the VRExchange API Minor version."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": minor version"]}),"\n",(0,s.jsx)(n.p,{children:"This version number represents additions to the API and does not affect backward compatibility."}),"\n",(0,s.jsx)(n.h3,{id:"vrximport",children:"VRXImport"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"uint32_t VRXImport(\r\n    const char * file,\r\n    HNode scenes,\r\n    HNode libs,\r\n    const char * importerName\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Imports the specified file onto the specified scenes and libraries nodes."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"file"})," The file to import"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"scenes"})," The root node to create assemblies on (e.g. scenes root)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"libs"})," The root node to create library assets on (e.g. libraries root)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"importerName"})," Hint to specify the name of the importer plugin to use. If not specified (null), attempts to determine a suitable importer using the file parameter's file extension"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": 1 if the import is successful, otherwise 0"]}),"\n",(0,s.jsx)(n.h3,{id:"vrximportandmerge",children:"VRXImportAndMerge"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"uint32_t VRXImportAndMerge(\r\n    const char * file,\r\n    HNode scenes,\r\n    HNode libs,\r\n    HNode mergeOptions,\r\n    const char * importerName\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Imports and merges the specified file onto the specified scenes and libraries nodes utilising the merge options to append the import data."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"file"})," The file to import"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"scenes"})," The root node to create assemblies on (e.g. scenes root)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"libs"})," The root node to create library assets on (e.g. libraries root)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"mergeOptions"})," If this node is set then the import merges results to existing nodes. This node contains the merge settings. If not specified (null), then imports as normal"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"importerName"})," Hint to specify the name of the importer plugin to use. If not specified (null), attempts to determine a suitable importer using the file parameter's file extension"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": 1 if the import is successful, otherwise 0"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var i=r(96540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);