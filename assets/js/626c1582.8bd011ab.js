"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[7270],{34876:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"visionary-render-programming/architecture/observers","title":"Observers","description":"The core of VRTree implements the Observer pattern to perform change subscription or notification. Node instances can be observed, meaning that callback functions are called in repsonse to changes to the tree structure or other node data.","source":"@site/docs/visionary-render-programming/architecture/observers.mdx","sourceDirName":"visionary-render-programming/architecture","slug":"/visionary-render-programming/architecture/observers","permalink":"/visionary-render-programming/architecture/observers","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/architecture/observers.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Nodes","permalink":"/visionary-render-programming/architecture/nodes"},"next":{"title":"Properties","permalink":"/visionary-render-programming/architecture/properties"}}');var s=t(74848),d=t(28453);const i={},a="Observers",o={},c=[];function l(e){const r={a:"a",code:"code",h1:"h1",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"observers",children:"Observers"})}),"\n",(0,s.jsx)(r.p,{children:"The core of VRTree implements the Observer pattern to perform change subscription or notification. Node instances can be observed, meaning that callback functions are called in repsonse to changes to the tree structure or other node data."}),"\n",(0,s.jsx)(r.p,{children:"The following observed events are exposed by the C API:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Event"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"VRAddCallbackNodeCreation"})}),(0,s.jsx)(r.td,{children:"Called immediately when a node is created"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"VRAddCallbackNodeDestruction"})}),(0,s.jsx)(r.td,{children:"Called immediately when a node is destroyed. Note that deleting nodes usually puts them in the recycle bin, which does not trigger this event."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"VRAddCallbackNodeValuesChanged"})}),(0,s.jsxs)(r.td,{children:["Called during the next notify traversal (not immediately) when a property of a node changes. Multiple property changes are queued up into a single call to this callback, and the ",(0,s.jsx)(r.code,{children:"VRIsDirty"})," function is used to determine whether a particular property has changed. It is important that this callback does not directly make further property modifications, as those may be missed by other observers that had already been notified during this traversal."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"VRAddCallbackNodeRenamed"})}),(0,s.jsx)(r.td,{children:"Called immediately when a node is renamed"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"VRAddCallbackNodeChildAdded"})}),(0,s.jsx)(r.td,{children:"Called immediately when a node is added as a child of the observed node"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"VRAddCallbackNodeChildRemoved"})}),(0,s.jsx)(r.td,{children:"Called immediately when a node is removed as a child of the observed node"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"VRAddCallbackNodeParentChanged"})}),(0,s.jsx)(r.td,{children:"Called immediately when a node's parent changes (i.e. when the observed node is moved somewhere else in the tree)"})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:["The Lua API (and by extension the C API via ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/plugins/tutorials/ffi",children:"FFI"}),") provides some additional observers to respond to internal scenegraph events, monitoring world transform and world enabled state of assemblies."]}),"\n",(0,s.jsxs)(r.p,{children:["This is discussed in the ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/scripts/metanodes/observers",children:"observers"})," page."]})]})}function h(e={}){const{wrapper:r}={...(0,d.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>a});var n=t(96540);const s={},d=n.createContext(s);function i(e){const r=n.useContext(d);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(d.Provider,{value:r},e.children)}}}]);