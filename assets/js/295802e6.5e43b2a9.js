"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[56628],{29034:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>l,contentTitle:()=>d,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"visionary-render/renderer/performance","title":"Performance","description":"Visionary Render has various settings that can be changed to improve the performance of the renderer (and therefore your scenes). The Diagnostics and Geometry Operators pages describe how to find and improve any performance issues with models in your scene. However, if your scene still isn\'t rendering quickly enough then this page covers additional renderer settings that you can change. These settings can be found in the Settings window (F6) under the Renderer category.","source":"@site/docs/visionary-render/renderer/performance.mdx","sourceDirName":"visionary-render/renderer","slug":"/visionary-render/renderer/performance","permalink":"/visionary-render/renderer/performance","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render/renderer/performance.mdx","tags":[],"version":"current","lastUpdatedAt":1741620509000,"frontMatter":{},"sidebar":"visionaryRenderSidebar","previous":{"title":"Particle Systems","permalink":"/visionary-render/renderer/particle-systems"},"next":{"title":"Point Clouds","permalink":"/visionary-render/renderer/point-clouds"}}');var t=r(74848),i=r(28453);const a={},d="Performance",l={},o=[{value:"General Settings",id:"general-settings",level:2},{value:"Scene Settings",id:"scene-settings",level:2},{value:"Level of Detail Settings",id:"level-of-detail-settings",level:2},{value:"Performance Settings",id:"performance-settings",level:2},{value:"Other Settings",id:"other-settings",level:2}];function h(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"performance",children:"Performance"})}),"\n",(0,t.jsxs)(s.p,{children:["Visionary Render has various settings that can be changed to improve the performance of the renderer (and therefore your scenes). The ",(0,t.jsx)(s.a,{href:"/visionary-render/windows/diagnostics",children:"Diagnostics"})," and ",(0,t.jsx)(s.a,{href:"/visionary-render/tools/geometry-operators",children:"Geometry Operators"})," pages describe how to find and improve any performance issues with models in your scene. However, if your scene still isn't rendering quickly enough then this page covers additional renderer settings that you can change. These settings can be found in the Settings window (",(0,t.jsx)(s.code,{children:"F6"}),") under the ",(0,t.jsx)(s.strong,{children:"Renderer"})," category."]}),"\n",(0,t.jsx)(s.h2,{id:"general-settings",children:"General Settings"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{src:r(26905).A+"",width:"764",height:"530"})}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Setting"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Stereo Optimisation"}),(0,t.jsxs)(s.td,{children:["The type of hardware optimisation to apply to stereo rendering. ",(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"None"})," - Render each eye in sequence on the primary GPU (slowest). ",(0,t.jsx)(s.em,{children:"[default]"})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Single GPU Parallel"})," - Render both eyes in parallel on the primary GPU if possible (Note: this requires an NVIDIA Pascal generation GPU or above)."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Dual GPU Parallel"})," - Render both eyes in parallel over two GPUs if possible (Note: this requires two NVIDIA Pascal generation GPUs or above)."]})]})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Render Mode"}),(0,t.jsxs)(s.td,{children:["Select Deferred to optimise scenes with many lights, and to allow certain image post-processing effects not otherwise possible with Forward mode. ",(0,t.jsx)(s.em,{children:"[default: Forward]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Display Sync"}),(0,t.jsxs)(s.td,{children:["This can be used to synchronise rendering with the physical display. ",(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Off"})," - Don't synchonise the renderer to the display refresh. - ",(0,t.jsx)(s.strong,{children:"On"})," - Synchonise the renderer to the display refresh. "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Default"})," - Use the system's default setting. ",(0,t.jsx)(s.em,{children:"[default]"})," "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Adaptive"})," - Synchronise to each display refresh only when the renderer's frame rate is faster than the display's refresh rate. "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Adaptive (Half Refresh Rate)"})," - Synchronise to every other display refresh only when the renderer's frame rate is faster than half the display's refresh rate."]})]})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Anti-aliasing"}),(0,t.jsxs)(s.td,{children:["Method of anti-aliasing to use, in order to reduce jagged edges and flickering pixels. Options are listed in worst to best image quality order. ",(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"None"})," - No anti-aliasing at all (fastest/worst quality). ",(0,t.jsx)(s.em,{children:"[default]"})," "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"FXAA"})," - Fast Approximate Anti-aliasing, a post-process image-based edge smoothing method. "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"MSAA x2"})," - 2x Multisampling. "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"MSAA x4"})," - 4x Multisampling. "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"MSAA x8"})," - 8x Multisampling. "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"MSAA x16"})," - 16x Multisampling (slowest/best quality)."]})]})]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"scene-settings",children:"Scene Settings"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{src:r(4193).A+"",width:"745",height:"482"})}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Setting"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Logarithmic Depth Buffer"}),(0,t.jsxs)(s.td,{children:["Enable to reduce z-fighting (i.e. the flickering of polygons that gets worse the further away they are from the camera). Note: This can result in lower framerates. ",(0,t.jsx)(s.em,{children:"[default: false]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Two-sided Lighting"}),(0,t.jsxs)(s.td,{children:["Enable two-sided lighting, which lights objects from both sides using their inverted normal. Note: This can result in lower framerates. ",(0,t.jsx)(s.em,{children:"[default: false]"})]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"level-of-detail-settings",children:"Level of Detail Settings"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{src:r(42308).A+"",width:"744",height:"482"})}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Setting"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"LOD Scale"}),(0,t.jsxs)(s.td,{children:["Scale to apply to level of detail distances in part geometry. A setting of 0 will disable all LOD effects. ",(0,t.jsx)(s.em,{children:"[default: 1.0]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Coverage LOD"}),(0,t.jsxs)(s.td,{children:["The level in the scene at which coverage LOD tests should be performed. Change this setting to apply a level of detail based on the screen space coverage of each object. If the object appears very small from your current viewpoint then it will not be rendered. If there is an Assembly in your scene that you do not want to be affected by Coverage LOD, open its properties and check the ",(0,t.jsx)(s.strong,{children:"Ignore Coverage LOD"})," property, as shown in the image below: ",(0,t.jsx)(s.img,{src:r(77690).A+"",width:"438",height:"462"}),(0,t.jsx)("br",{}),(0,t.jsx)(s.em,{children:"[default: false]"})]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"performance-settings",children:"Performance Settings"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{src:r(5275).A+"",width:"764",height:"530"})}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Setting"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Overlapped Culling"}),(0,t.jsxs)(s.td,{children:["This improves rendering speed for scenes with a huge hierarchy, such as when the Diagnostics window is showing a high cull number in the cull/draw statistic. It will offload the cull to another thread, which allows it to prepare the next frame for drawing whilst the current frame is still drawing. The drawback to this is that it adds a frame of latency in the worst-case scenario. ",(0,t.jsx)(s.em,{children:"[default: false]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Occlusion Culling"}),(0,t.jsxs)(s.td,{children:["This improves rendering speed by eliminating the work involved in drawing objects that are hidden behind other objects and therefore invisible to the viewer. Enabling this setting will help to reduce the cull time if you're seeing a high number in ",(0,t.jsx)(s.strong,{children:"Diagnostics"})," > ",(0,t.jsx)(s.strong,{children:"View"}),". ",(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Multiplier"})," - Increasing this trades accuracy for occlusion performance. "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Depth Bias"})," - A value to stop self-occlusion. Increasing this trades performance for a reduction in error, reducing side effects such as flickering. "]})]})," ",(0,t.jsx)(s.em,{children:"[default: false]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Instance GeoGroups"}),(0,t.jsxs)(s.td,{children:["Enable hardware instancing. If you are using many instances of the same models then you may see a performance improvement by enabling this setting. By instancing GeoGroups, you can reduce the number of batches (draw commands sent to the GPU). This can be tracked with the Batches Histogram in ",(0,t.jsx)(s.strong,{children:"Diagnostics"})," > ",(0,t.jsx)(s.strong,{children:"View"}),". The setting has two child settings: ",(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Instance Threshold"})," - The number of instances of a GeoGroup that must exist before they're all drawn in a single batch using hardware instancing. ",(0,t.jsx)(s.em,{children:"[default: 0]"})," "]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(s.strong,{children:"Instance Vertex Limit"})," - If a GeoGroup has more than this number of vertices, it will not be instanced. A special value of 0 means no limit, so all GeoGroups will be instanced. ",(0,t.jsx)(s.em,{children:"[default: 1000]"})," "]})]})," ",(0,t.jsx)(s.em,{children:"[default: true]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Shader Cache"}),(0,t.jsxs)(s.td,{children:["Enable this to reduce the time spent building shaders by storing them on your local disk. ",(0,t.jsx)(s.em,{children:"[default: true]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Save Shader Hashes"}),(0,t.jsxs)(s.td,{children:["Save hashes of shader configurations to the Scene so that when reloaded the renderer can pre-compile all necessary shaders. This will lead to an increased load time but should help minimize any stuttering due to shader recompilation once the scene is loaded. ",(0,t.jsx)(s.em,{children:"[default: false]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Point Cloud Cache Size"}),(0,t.jsxs)(s.td,{children:["The percentage of total computer memory to make available for caching point clouds. If your scene contains point clouds then increasing this value could improve your frame rate if the cache limit is being reached. ",(0,t.jsx)(s.em,{children:"[default: 100]"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Stop Rendering When Static"}),(0,t.jsxs)(s.td,{children:["Reduces CPU/GPU usage and improves GUI responsiveness by only re-rendering the 3D scene when changes to the scene or camera are detected. ",(0,t.jsx)(s.em,{children:"[default: true]"})]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"other-settings",children:"Other Settings"}),"\n",(0,t.jsx)(s.p,{children:"There are various other renderer settings that can affect performance if enabled, such as Procedural Sky, High Dynamic Range, Ambient Occlusion, Screen Space Reflections and Image-based Lighting. If you require better performance then you can seek to reduce the quality of these settings if possible or disable them completely, although obviously this will affect the quality of the rendering and it will need to be weighed up against the gain in performance."})]})}function c(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},26905:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/general-f9aae5373478d206c3d3eb8f1587761e.png"},42308:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/lod-70fbaa8446702dc001a96b47395558b8.png"},5275:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/performance-e76d2541d5c8b746af5e1357b6eca884.png"},77690:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/properties-375c577fc810cdabdc113175a89a838f.png"},4193:(e,s,r)=>{r.d(s,{A:()=>n});const n=r.p+"assets/images/scene-cdfc17ed6ad4f256251892c8b2cb40e1.png"},28453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>d});var n=r(96540);const t={},i=n.createContext(t);function a(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);