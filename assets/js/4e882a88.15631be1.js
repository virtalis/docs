"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[43457],{2550:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"visionary-render-programming/reference/lua-api/classes/vrnode","title":"vrnode","description":"Module: Node","source":"@site/docs/visionary-render-programming/reference/lua-api/classes/vrnode.mdx","sourceDirName":"visionary-render-programming/reference/lua-api/classes","slug":"/visionary-render-programming/reference/lua-api/classes/vrnode","permalink":"/visionary-render-programming/reference/lua-api/classes/vrnode","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/lua-api/classes/vrnode.mdx","tags":[],"version":"current","lastUpdatedAt":1730817102000,"frontMatter":{"title":"vrnode","summary":"A node in the tree."},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"vrmatrix4","permalink":"/visionary-render-programming/reference/lua-api/classes/vrmatrix4"},"next":{"title":"vrplane","permalink":"/visionary-render-programming/reference/lua-api/classes/vrplane"}}');var i=r(74848),t=r(28453);const d={title:"vrnode",summary:"A node in the tree."},a="vrnode",l={},o=[{value:"Public Functions",id:"public-functions",level:2},{value:"Public Functions Documentation",id:"public-functions-documentation",level:2},{value:"ancestor",id:"ancestor",level:3},{value:"child",id:"child",level:3},{value:"childbyindex",id:"childbyindex",level:3},{value:"count",id:"count",level:3},{value:"find",id:"find",level:3},{value:"forEachChild",id:"foreachchild",level:3},{value:"forEachChildOfType",id:"foreachchildoftype",level:3},{value:"getName",id:"getname",level:3},{value:"getParent",id:"getparent",level:3},{value:"getRelative",id:"getrelative",level:3},{value:"hasTrait",id:"hastrait",level:3},{value:"next",id:"next",level:3},{value:"parent",id:"parent",level:3},{value:"path",id:"path",level:3},{value:"previous",id:"previous",level:3},{value:"relpath",id:"relpath",level:3},{value:"setName",id:"setname",level:3},{value:"setParent",id:"setparent",level:3},{value:"setRelative",id:"setrelative",level:3},{value:"sibling",id:"sibling",level:3},{value:"tail",id:"tail",level:3},{value:"traits",id:"traits",level:3},{value:"type",id:"type",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"vrnode",children:"vrnode"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Module:"})," ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/modules/nodes",children:"Node"})})]}),"\n",(0,i.jsx)(n.p,{children:"A node in the tree."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"#include <lua_api.h>"})}),"\n",(0,i.jsx)(n.h2,{id:"public-functions",children:"Public Functions"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Name"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#ancestor",children:"ancestor"})}),"(string metaName)",(0,i.jsx)("br",{}),"(vrNodeGetAncestor) Gets the first ancestor of the specified type"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#child",children:"child"})}),"(string metaType =0, string name =0)",(0,i.jsx)("br",{}),"(vrNodeGetChild) Gets the first child of a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#childbyindex",children:"childbyindex"})}),"(number idx)",(0,i.jsx)("br",{}),"(vrNodeGetChildByIndex) Gets a nodes child by its zero-based index. Note: this function may result in poor performance when iterating over lots of nodes - use vrNodeGetChild() and vrNodeGetSibling() instead (see the Best Practices section of the Programming Guide for more info)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"number"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#count",children:"count"})}),"()",(0,i.jsx)("br",{}),"(vrNodeGetChildCount) Counts the children of a node. Note: this function may result in poor performance when iterating over lots of nodes - use vrNodeGetChild() and vrNodeGetSibling() instead (see the Best Practices section of the Programming Guide for more info)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#find",children:"find"})}),"(string path, boolean caseSensitive =true)",(0,i.jsx)("br",{}),"(vrNodeFindChild) Finds a descendant of a node by path"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"void"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#foreachchild",children:"forEachChild"})}),"(Any function)",(0,i.jsx)("br",{}),"(vrNodeForEachChild) Calls a function for each child of a node"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"void"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#foreachchildoftype",children:"forEachChildOfType"})}),"(string metaType, Any function)",(0,i.jsx)("br",{}),"(vrNodeForEachChildOfType) Calls a function for each child of a node that matches a specified type"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"string"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#getname",children:"getName"})}),"()",(0,i.jsx)("br",{}),"(vrNodeGetName) Gets the name of a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#getparent",children:"getParent"})}),"()",(0,i.jsx)("br",{}),"(vrNodeGetParent) Gets the parent of a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/multi",children:"MULTI"}),"< ",(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrvec3",children:"vrvec3"}),", ",(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrvec3",children:"vrvec3"}),", ",(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrvec3",children:"vrvec3"})," >"]}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#getrelative",children:"getRelative"})}),"(string propName, ",(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})," otherNode)",(0,i.jsx)("br",{}),"(vrNodeGetRelativeTransform) Gets the position, rotation and scale of the world transform of one node relative to another."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#hastrait",children:"hasTrait"})}),"(string traitName)",(0,i.jsx)("br",{}),"(vrNodeHasTrait) Checks if the node is of a type with a specific trait. This is a lot faster than vrNodeGetTraits"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#next",children:"next"})}),"(string metaType =0, string name =0)",(0,i.jsx)("br",{}),"(vrNodeGetSibling) Gets the sibling (adjacent) node to a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#parent",children:"parent"})}),"()",(0,i.jsx)("br",{}),"(vrNodeGetParent) Gets the parent of a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"string"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#path",children:"path"})}),"()",(0,i.jsx)("br",{}),"(vrNodeGetPath) Gets the encoded path to a node relative to the tree root"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#previous",children:"previous"})}),"(string metaType =0, string name =0)",(0,i.jsx)("br",{}),"(vrNodeGetPreviousSibling) Gets the previous sibling (adjacent) node to a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"string"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#relpath",children:"relpath"})}),"(vrnode](../classes/vrnode.mdx) relativeTo)",(0,i.jsx)("br",{}),"(vrNodeGetRelativePath) Gets the encoded path to a node, relative to another node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"void"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#setname",children:"setName"})}),"(string newName)",(0,i.jsx)("br",{}),"(vrNodeSetName) Sets the name of a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"void"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#setparent",children:"setParent"})}),"(vrnode](../classes/vrnode.mdx) parent =nil, ",(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})," beforeSibling =nil, boolean preserveWorldTransform =false)",(0,i.jsx)("br",{}),"(vrNodeSetParent) Sets the parent of a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"void"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#setrelative",children:"setRelative"})}),"(string propName, ",(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})," otherNode, Any vpos, Any vrot, Any vscale)",(0,i.jsx)("br",{}),"(vrNodeSetRelativeTransform) Sets the position, rotation and scale of the world transform of a node relative to another."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#sibling",children:"sibling"})}),"(string metaType =0, string name =0)",(0,i.jsx)("br",{}),"(vrNodeGetSibling) Gets the sibling (adjacent) node to a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/visionary-render-programming/reference/lua-api/classes/vrnode",children:"vrnode"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#tail",children:"tail"})}),"(string metaType =0, string name =0)",(0,i.jsx)("br",{}),"(vrNodeGetTail) Gets the last child of a node."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"table"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#traits",children:"traits"})}),"()",(0,i.jsx)("br",{}),"(vrNodeGetTraits) Gets the list of traits that this node has. Can also be thought of as the base class of a node (e.g. Texture, Viewport, etc). This function is expensive and can affect performance. To check a specific trait use vrNodeHasTrait"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"string"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"#type",children:"type"})}),"(boolean versioned =false)",(0,i.jsx)("br",{}),"(vrNodeGetMetaNode) Gets the name of the MetaNode that a node is an instance of. This can also be referred to as the node type."]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"public-functions-documentation",children:"Public Functions Documentation"}),"\n",(0,i.jsx)(n.h3,{id:"ancestor",children:"ancestor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode ancestor(\r\n    string metaName\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetAncestor) Gets the first ancestor of the specified type"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"metaName"})," The type of ancestor to look for"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": Ancestor node of the specified type, or false if there isn't one"]}),"\n",(0,i.jsx)(n.h3,{id:"child",children:"child"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode child(\r\n    string metaType =0,\r\n    string name =0\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetChild) Gets the first child of a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"metaType"})," The type of child to get"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"})," The name of the child to get"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The first child node, of the type in the metaType parameter, if specified, or false if there are no suitable child nodes"]}),"\n",(0,i.jsx)(n.h3,{id:"childbyindex",children:"childbyindex"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode childbyindex(\r\n    number idx\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetChildByIndex) Gets a nodes child by its zero-based index. Note: this function may result in poor performance when iterating over lots of nodes - use [vrNodeGetChild() and [vrNodeGetSibling() instead (see the Best Practices section of the Programming Guide for more info)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"idx"})," The index of the child (zero based)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The specified child node, or false if out of range"]}),"\n",(0,i.jsx)(n.h3,{id:"count",children:"count"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"number count()\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetChildCount) Counts the children of a node. Note: this function may result in poor performance when iterating over lots of nodes - use [vrNodeGetChild() and [vrNodeGetSibling() instead (see the Best Practices section of the Programming Guide for more info)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The number of direct child nodes"]}),"\n",(0,i.jsx)(n.h3,{id:"find",children:"find"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode find(\r\n    string path,\r\n    boolean caseSensitive =true\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeFindChild) Finds a descendant of a node by path"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"path"})," The path or name of the node to search from"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"caseSensitive"})," Whether to match case in the path"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The node at the specified path, or false if not found"]}),"\n",(0,i.jsx)(n.h3,{id:"foreachchild",children:"forEachChild"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"void forEachChild(\r\n    Any function\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeForEachChild) Calls a function for each child of a node"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"function"})," The function to call for each child node. This function should have a signature of function(node). This can be a string name of a global function, or a lua function object. If the function returns a value other than nil, the function will not be called for further children and the value will be returned to the caller"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"foreachchildoftype",children:"forEachChildOfType"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"void forEachChildOfType(\r\n    string metaType,\r\n    Any function\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeForEachChildOfType) Calls a function for each child of a node that matches a specified type"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"metaType"})," The type of child nodes to find"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"function"})," The function to call for each child node. This function should have a signature of function(node). This can be a string name of a global function, or a lua function object. If the function returns a value other than nil, the function will not be called for further children and the value will be returned to the caller"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"getname",children:"getName"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"string getName()\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetName) Gets the name of a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The name of the node"]}),"\n",(0,i.jsx)(n.h3,{id:"getparent",children:"getParent"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode getParent()\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetParent) Gets the parent of a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The parent node"]}),"\n",(0,i.jsx)(n.h3,{id:"getrelative",children:"getRelative"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"MULTI< vrvec3, vrvec3, vrvec3 > getRelative(\r\n    string propName,\r\n    vrnode otherNode\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetRelativeTransform) Gets the position, rotation and scale of the world transform of one node relative to another."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The relative world position"}),"\n",(0,i.jsx)(n.li,{children:"The relative world rotation"}),"\n",(0,i.jsx)(n.li,{children:"The relative world scale"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"hastrait",children:"hasTrait"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"boolean hasTrait(\r\n    string traitName\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeHasTrait) Checks if the node is of a type with a specific trait. This is a lot faster than vrNodeGetTraits"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"traitName"})," The name of the trait to check"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": true if the node has the specified trait"]}),"\n",(0,i.jsx)(n.h3,{id:"next",children:"next"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode next(\r\n    string metaType =0,\r\n    string name =0\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetSibling) Gets the sibling (adjacent) node to a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"metaType"})," The type of sibling to get"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"})," The name of the child to get"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The next sibling node, of the type in the metaType parameter, if specified, or false if there are no suitable siblings"]}),"\n",(0,i.jsx)(n.h3,{id:"parent",children:"parent"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode parent()\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetParent) Gets the parent of a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The parent node"]}),"\n",(0,i.jsx)(n.h3,{id:"path",children:"path"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"string path()\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetPath) Gets the encoded path to a node relative to the tree root"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The encoded path (special characters are encoded, e.g. space = %20)"]}),"\n",(0,i.jsx)(n.h3,{id:"previous",children:"previous"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode previous(\r\n    string metaType =0,\r\n    string name =0\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetPreviousSibling) Gets the previous sibling (adjacent) node to a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"metaType"})," The type of sibling to get"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"})," The name of the child to get"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The previous sibling node, of the type in the metaType parameter, if specified, or false if there are no suitable siblings"]}),"\n",(0,i.jsx)(n.h3,{id:"relpath",children:"relpath"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"string relpath(\r\n    vrnode relativeTo\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetRelativePath) Gets the encoded path to a node, relative to another node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"relativeTo"})," The node to get the path relative to"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The encoded relative path (special characters are encoded, e.g. space = %20)"]}),"\n",(0,i.jsx)(n.h3,{id:"setname",children:"setName"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"void setName(\r\n    string newName\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeSetName) Sets the name of a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"newName"})," The new name for the node"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"setparent",children:"setParent"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"void setParent(\r\n    vrnode parent =nil,\r\n    vrnode beforeSibling =nil,\r\n    boolean preserveWorldTransform =false\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeSetParent) Sets the parent of a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"parent"})," New parent. If this is nil, the parent is cleared, effectively deleting the node from the tree."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"beforeSibling"})," Specifies where to add the node in the parent's list of children, or nil to add it at the end of the list."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"preserveWorldTransform"})," If true, the node's position, rotation and scale in the world will be maintained."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"setrelative",children:"setRelative"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"void setRelative(\r\n    string propName,\r\n    vrnode otherNode,\r\n    Any vpos,\r\n    Any vrot,\r\n    Any vscale\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeSetRelativeTransform) Sets the position, rotation and scale of the world transform of a node relative to another."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"vpos"})," XYZ Position specified in a table {x, y, z}."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"vrot"})," Euler Rotation specified in a table {x, y, z}."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"vscale"})," XYZ Scale specified in a table {x, y, z}."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"sibling",children:"sibling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode sibling(\r\n    string metaType =0,\r\n    string name =0\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetSibling) Gets the sibling (adjacent) node to a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"metaType"})," The type of sibling to get"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"})," The name of the child to get"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The next sibling node, of the type in the metaType parameter, if specified, or false if there are no suitable siblings"]}),"\n",(0,i.jsx)(n.h3,{id:"tail",children:"tail"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"vrnode tail(\r\n    string metaType =0,\r\n    string name =0\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetTail) Gets the last child of a node."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"metaType"})," The type of child to get"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"name"})," The name of the child to get"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The last child node, of the type in the metaType parameter, if specified, or false if there are no suitable child nodes"]}),"\n",(0,i.jsx)(n.h3,{id:"traits",children:"traits"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"table traits()\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetTraits) Gets the list of traits that this node has. Can also be thought of as the base class of a node (e.g. Texture, Viewport, etc). This function is expensive and can affect performance. To check a specific trait use vrNodeHasTrait"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": Array of traits that this node has"]}),"\n",(0,i.jsx)(n.h3,{id:"type",children:"type"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"string type(\r\n    boolean versioned =false\r\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"(vrNodeGetMetaNode) Gets the name of the MetaNode that a node is an instance of. This can also be referred to as the node type."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"versioned"})," Whether to get the full versioned metanode name rather than the unversioned name"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return"}),": The node type"]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>a});var s=r(96540);const i={},t=s.createContext(i);function d(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);