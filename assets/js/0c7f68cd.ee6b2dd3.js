"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[1196],{37258:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"visionary-render-programming/reference/c-api/classes/metanodes/meta-assembly-prs","title":"Meta_AssemblyPRS","description":"Module: Metanodes / Definitions","source":"@site/docs/visionary-render-programming/reference/c-api/classes/metanodes/meta-assembly-prs.mdx","sourceDirName":"visionary-render-programming/reference/c-api/classes/metanodes","slug":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-assembly-prs","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-assembly-prs","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/c-api/classes/metanodes/meta-assembly-prs.mdx","tags":[],"version":"current","lastUpdatedAt":1730817102000,"frontMatter":{"title":"Meta_AssemblyPRS","summary":"An AssemblyPRS node is used to store hints for matrix edit gui controls."},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Meta_ARMarker","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-ar-marker"},"next":{"title":"Meta_AssemblyTrack","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-assembly-track"}}');var n=r(74848),i=r(28453);const a={title:"Meta_AssemblyPRS",summary:"An AssemblyPRS node is used to store hints for matrix edit gui controls."},d="Meta_AssemblyPRS",o={},l=[{value:"Public Types",id:"public-types",level:2},{value:"Detailed Description",id:"detailed-description",level:2},{value:"Public Types Documentation",id:"public-types-documentation",level:2},{value:"enum IDX",id:"enum-idx",level:3}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"meta_assemblyprs",children:"Meta_AssemblyPRS"})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Module:"})," ",(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/",children:"Metanodes"})})," ",(0,n.jsx)(s.strong,{children:"/"})," ",(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/definitions",children:"Definitions"})})]}),"\n",(0,n.jsxs)(s.p,{children:["An AssemblyPRS node is used to store hints for matrix edit gui controls.  ",(0,n.jsx)(s.a,{href:"#detailed-description",children:"More..."})]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.code,{children:"#include <meta_division.hpp>"})}),"\n",(0,n.jsx)(s.h2,{id:"public-types",children:"Public Types"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Type"}),(0,n.jsx)(s.th,{children:"Name"})]})}),(0,n.jsx)(s.tbody,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"enum"}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"#enum-idx",children:"IDX"})})," { Idx_Position, Idx_Rotation, Idx_Scale }",(0,n.jsx)("br",{}),"Property Index."]})]})})]}),"\n",(0,n.jsx)(s.h2,{id:"detailed-description",children:"Detailed Description"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cpp",children:"struct Meta_AssemblyPRS;\n"})}),"\n",(0,n.jsx)(s.p,{children:"An AssemblyPRS node is used to store hints for matrix edit gui controls."}),"\n",(0,n.jsx)(s.p,{children:"This exists because the standard transform controls decompose the matrix into position, rotation, and scale. Decomposition to euler angles regularly results in unexpected values that make it look like the rotation is incorrect, when it is just another possible valid euler representation."}),"\n",(0,n.jsx)(s.p,{children:"This node is automatically created when the user interface edits a transform property on an assembly, and is read first when re-selecting the assembly. It is then composed and compared against the transform property to verify it is still up to date."}),"\n",(0,n.jsx)(s.h2,{id:"public-types-documentation",children:"Public Types Documentation"}),"\n",(0,n.jsx)(s.h3,{id:"enum-idx",children:"enum IDX"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Enumerator"}),(0,n.jsx)(s.th,{children:"Value"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Position"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"vec3w - Translation"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Rotation"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"vec3w - Rotation (eulers)"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Scale"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"vec3w - Scale"})]})]})]}),"\n",(0,n.jsx)(s.p,{children:"Property Index."})]})}function m(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>d});var t=r(96540);const n={},i=t.createContext(n);function a(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);