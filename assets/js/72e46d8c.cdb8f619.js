"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[42182],{40729:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"visionary-render-programming/scripts/metanodes/assembly","title":"Assembly","description":"This node type describes position, rotation and scale properties, as well as constraint information.","source":"@site/docs/visionary-render-programming/scripts/metanodes/assembly.mdx","sourceDirName":"visionary-render-programming/scripts/metanodes","slug":"/visionary-render-programming/scripts/metanodes/assembly","permalink":"/visionary-render-programming/scripts/metanodes/assembly","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/scripts/metanodes/assembly.mdx","tags":[],"version":"current","lastUpdatedAt":1730817102000,"frontMatter":{},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Events","permalink":"/visionary-render-programming/scripts/getting-started/events"},"next":{"title":"Audio","permalink":"/visionary-render-programming/scripts/metanodes/audio"}}');var s=n(74848),o=n(28453);const i={},a="Assembly",l={},d=[{value:"Properties",id:"properties",level:2},{value:"Constraint Types",id:"constraint-types",level:3},{value:"Examples",id:"examples",level:2},{value:"Direct Property Access",id:"direct-property-access",level:3},{value:"Working with Transforms",id:"working-with-transforms",level:3}];function c(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"assembly",children:"Assembly"})}),"\n",(0,s.jsx)(r.p,{children:"This node type describes position, rotation and scale properties, as well as constraint information."}),"\n",(0,s.jsx)(r.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Property"}),(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Enabled"}),(0,s.jsx)(r.td,{children:"boolean"}),(0,s.jsx)(r.td,{children:"Enabled or disabled."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Transform"}),(0,s.jsx)(r.td,{children:"vrmat4"}),(0,s.jsx)(r.td,{children:"The raw transformation matrix."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Constraint"}),(0,s.jsx)(r.td,{children:"number"}),(0,s.jsx)(r.td,{children:"Type of constraint. See constraint type table below."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"CollisionLayer"}),(0,s.jsx)(r.td,{children:"number"}),(0,s.jsx)(r.td,{children:"A signed integer representing the collision layer of this assembly. Higher values take priority over lower values. I.e. if multiple ray intersections are returned from the collision system, then the one associated with an assembly with the highest layer value will be used."})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"constraint-types",children:"Constraint Types"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type String"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"__Assembly_ConstraintNone"})}),(0,s.jsx)(r.td,{children:"No constraint is applied"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"__Assembly_ConstraintLock"})}),(0,s.jsx)(r.td,{children:"No changes to the local transform are allowed"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"__Assembly_ConstraintParent"})}),(0,s.jsx)(r.td,{children:"Defers transform changes to the parent assembly. Moving this assembly moves the parent instead."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"__Assembly_ConstraintLimit"})}),(0,s.jsx)(r.td,{children:"Constraints the assembly according to the parameters of the TransformLimits child node (which might need creating if it does not exist)"})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(r.h3,{id:"direct-property-access",children:"Direct Property Access"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"-- Drag/Drop section BEGINS - Do not edit between BEGINS and ENDS.\r\nlocal King_white = __Script.dragdrop.King_white\r\n-- Drag/Drop section ENDS\r\n\r\n-- toggle the Enabled state of the Assembly\r\nKing_white.Enabled = not King_white.Enabled\r\n\r\n-- get the local transform values of the king\r\nlocal xform = King_white.Transform\r\n\r\n-- add 0.01 to the Y value of the position - this immediately applies to the assembly\r\nxform.Position.Y = xform.Position.Y + 0.01\n"})}),"\n",(0,s.jsx)(r.h3,{id:"working-with-transforms",children:"Working with Transforms"}),"\n",(0,s.jsx)(r.p,{children:"The transform property provides a special set of objects that allow direct control over the assembly, as opposed to having to read a transform out, modify it, then write it back."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local test = vrTreeRoot():find("root/Scenes/Cube")\r\n\r\n-- Set position of an assembly.\r\ntest.Transform.Position = vrVec3(0, 0.1, 0)\r\ntest.Transform.Position = {0, 0.1, 0}\r\n\r\n-- Set the rotation of an assembly.\r\ntest.Transform.Rotation = vrVec3(90, 0, 180)\r\ntest.Transform.Rotation = {90, 0, 180}\r\n\r\n-- Set the scale\r\ntest.Transform.Scale = vrVec3(2, 2, 2)\r\ntest.Transform.Scale = {2, 2, 2}\r\n\r\n-- Set the x component of the nodes position.\r\ntest.Transform.Position.X = 10\r\n\r\n-- Set the x component of the nodes world position.\r\ntest.WorldTransform.Position.X = 20\r\n\r\n-- Create a new transform\r\nlocal newTransform = vrMat4()\r\nnewTransform.Position = {10, 10, 10}\r\n\r\n-- Assign a new transform to a node\r\ntest.Transform = newTransform\n'})}),"\n",(0,s.jsxs)(r.p,{children:["Care should be taken when assigning variables from transforms, because, with the exception of individual elements (e.g ",(0,s.jsx)(r.code,{children:"Transform.Position.X"}),"), they are references to the matrix rather than a copy."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'-- If you assign any part of a nodes transform to a variable, it is a reference.\r\nlocal newNode = vrCreateNode("Assembly", "newNode", test)\r\nlocal pos = newNode.Transform.Position\r\nlocal xPos = newNode.Transform.Position.X\r\n\r\n-- pos is now a reference to newNode.Transform.Position\r\npos.X = 5\r\n-- newNode.Transform.Position.x == 5\r\n\r\n-- xPos is not a reference to newNode.Transform.Position.X since it is just a number, it is copied.\r\nxPos = 10\r\n-- newNode.Transform.Position.x == 5\r\n\r\n-- pos is only valid as long as the node exists.\r\nvrDeleteNode(newNode)\r\npos.X = 10 -- ERROR (only if the history manager is disabled, otherwise the node will still exist in the recycling bin)\r\n\r\n-- xPos can still be assigned to since it was copied.\r\nxPos = 20\n'})}),"\n",(0,s.jsxs)(r.p,{children:["Scripts can also work directly with a matrix before setting the ",(0,s.jsx)(r.code,{children:"Transform"})," property"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"-- Construct matrix transformations\r\nlocal newMat = vrMat4()\r\nnewMat = vrMatRotateEulerX(newMat, 10)\r\nnewMat = vrMatTranslate(newMat, {10, 10, 10})\r\nnewMat = vrMatScale(newMat, {2, 2, 2})\n"})}),"\n",(0,s.jsx)(r.p,{children:"Scripts can multiply, add and subtract matrices from one another, as well as transform\r\nvectors using the multiplication operator"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"local newMat = vrMat4()\r\nnewMat.Position = {100, 0, 0}\r\nlocal otherMat = vrMat4()\r\notherMat.Rotation = {10, 20, 30}\r\n\r\nlocal combinedMat = newMat * otherMat\r\nlocal transformedVec = combinedMat * vrVec3(0, 0, 0)\n"})})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>a});var t=n(96540);const s={},o=t.createContext(s);function i(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);