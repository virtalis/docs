"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[1781],{32090:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>o,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper","title":"vrtree_cpp::HTypeR","description":"Reference counted wrapper around a handle. Automatically closes the handle when there are no references left.  More...","source":"@site/docs/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper.mdx","sourceDirName":"visionary-render-programming/reference/c-api/classes","slug":"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper","permalink":"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper.mdx","tags":[],"version":"current","lastUpdatedAt":1730820727000,"frontMatter":{"title":"vrtree_cpp::HTypeR","summary":"Reference counted wrapper around a handle. Automatically closes the handle when there are no references left."},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"vrtree_cpp::HRefCount","permalink":"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-hrefcount"},"next":{"title":"vrtree_cpp::NodeManager","permalink":"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-nodemanager"}}');var s=n(74848),c=n(28453);const i={title:"vrtree_cpp::HTypeR",summary:"Reference counted wrapper around a handle. Automatically closes the handle when there are no references left."},l="vrtree_cpp::HTypeR",a={},d=[{value:"Public Functions",id:"public-functions",level:2},{value:"Public Attributes",id:"public-attributes",level:2},{value:"Detailed Description",id:"detailed-description",level:2},{value:"Public Functions Documentation",id:"public-functions-documentation",level:2},{value:"dec",id:"dec",level:3},{value:"HTypeR",id:"htyper",level:3},{value:"HTypeR",id:"htyper-1",level:3},{value:"HTypeR",id:"htyper-2",level:3},{value:"inc",id:"inc",level:3},{value:"operator T",id:"operator-t",level:3},{value:"operator&lt;",id:"operator",level:3},{value:"operator=",id:"operator-1",level:3},{value:"operator=",id:"operator-2",level:3},{value:"~HTypeR",id:"htyper-3",level:3},{value:"raw",id:"raw",level:3},{value:"Public Attributes Documentation",id:"public-attributes-documentation",level:2},{value:"m_handle",id:"m_handle",level:3},{value:"ptr",id:"ptr",level:3}];function h(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"vrtree_cpphtyper",children:"vrtree_cpp::HTypeR"})}),"\n",(0,s.jsxs)(r.p,{children:["Reference counted wrapper around a handle. Automatically closes the handle when there are no references left.  ",(0,s.jsx)(r.a,{href:"#detailed-description",children:"More..."})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.code,{children:"#include <interface_helpers.hpp>"})}),"\n",(0,s.jsx)(r.h2,{id:"public-functions",children:"Public Functions"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Name"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"void"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#dec",children:"dec"})}),"()",(0,s.jsx)("br",{}),"Manually decrement the refcount. If recount hits zero, handle is closed."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#htyper",children:"HTypeR"})}),"()",(0,s.jsx)("br",{}),"Construct a null handle."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#htyper-1",children:"HTypeR"})}),"(T handle)",(0,s.jsx)("br",{}),"Construct from a raw node handle and make it refcounted."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#htyper-2",children:"HTypeR"})}),"(const ",(0,s.jsx)(r.a,{href:"#htyper",children:"HTypeR"}),"< T > & other)",(0,s.jsx)("br",{}),"Copy an existing handle, incrementing its refcount."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"void"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#inc",children:"inc"})}),"()",(0,s.jsx)("br",{}),"Manually increment the refcount (effectively makes the handle permanent until manually closed)"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#operator-t",children:"operator T"})}),"() const",(0,s.jsx)("br",{}),"Access the raw node handle."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"bool"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#operator",children:"operator<"})}),"(T other) const",(0,s.jsx)("br",{}),"Compare the raw node handle for storage in ordered containers."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.a,{href:"#htyper",children:"HTypeR"}),"< T > &"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#operator-1",children:"operator="})}),"(const ",(0,s.jsx)(r.a,{href:"#htyper",children:"HTypeR"}),"< T > & other)",(0,s.jsx)("br",{}),"Assign an existing handle."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.a,{href:"#htyper",children:"HTypeR"}),"< T > &"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#operator-2",children:"operator="})}),"(T handle)",(0,s.jsx)("br",{}),"Assign a raw handle and make it refcounted."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#htyper-3",children:"~HTypeR"})}),"()",(0,s.jsx)("br",{}),"Decrements refcount, closing the node handle if this is the last reference."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"T *"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#raw",children:"raw"})}),"(const ",(0,s.jsx)(r.a,{href:"#htyper",children:"HTypeR"}),"< T > arr[])",(0,s.jsx)("br",{}),"Converts an array of reference counted handles to an array of raw handles for passing to an api function that expects an array of handles. Return value is only valid until the next call to this function."]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"public-attributes",children:"Public Attributes"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Name"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"T"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#m_handle",children:"m_handle"})})," ",(0,s.jsx)("br",{}),"The handle to wrap."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-hrefcount",children:"HRefCount"})," *"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#ptr",children:"ptr"})})," ",(0,s.jsx)("br",{}),"Reference counter. Automatically deletes itself when the refcount is zero."]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"detailed-description",children:"Detailed Description"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"template <typename T >\r\nstruct vrtree_cpp::HTypeR;\n"})}),"\n",(0,s.jsx)(r.p,{children:"Reference counted wrapper around a handle. Automatically closes the handle when there are no references left."}),"\n",(0,s.jsx)(r.h2,{id:"public-functions-documentation",children:"Public Functions Documentation"}),"\n",(0,s.jsx)(r.h3,{id:"dec",children:"dec"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline void dec()\n"})}),"\n",(0,s.jsx)(r.p,{children:"Manually decrement the refcount. If recount hits zero, handle is closed."}),"\n",(0,s.jsx)(r.h3,{id:"htyper",children:"HTypeR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline HTypeR()\n"})}),"\n",(0,s.jsx)(r.p,{children:"Construct a null handle."}),"\n",(0,s.jsx)(r.h3,{id:"htyper-1",children:"HTypeR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline HTypeR(\r\n    T handle\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Construct from a raw node handle and make it refcounted."}),"\n",(0,s.jsx)(r.h3,{id:"htyper-2",children:"HTypeR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline HTypeR(\r\n    const HTypeR< T > & other\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Copy an existing handle, incrementing its refcount."}),"\n",(0,s.jsx)(r.h3,{id:"inc",children:"inc"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline void inc()\n"})}),"\n",(0,s.jsx)(r.p,{children:"Manually increment the refcount (effectively makes the handle permanent until manually closed)"}),"\n",(0,s.jsx)(r.h3,{id:"operator-t",children:"operator T"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline operator T() const\n"})}),"\n",(0,s.jsx)(r.p,{children:"Access the raw node handle."}),"\n",(0,s.jsx)(r.h3,{id:"operator",children:"operator<"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline bool operator<(\r\n    T other\r\n) const\n"})}),"\n",(0,s.jsx)(r.p,{children:"Compare the raw node handle for storage in ordered containers."}),"\n",(0,s.jsx)(r.h3,{id:"operator-1",children:"operator="}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline HTypeR< T > & operator=(\r\n    const HTypeR< T > & other\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Assign an existing handle."}),"\n",(0,s.jsx)(r.h3,{id:"operator-2",children:"operator="}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline HTypeR< T > & operator=(\r\n    T handle\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Assign a raw handle and make it refcounted."}),"\n",(0,s.jsx)(r.h3,{id:"htyper-3",children:"~HTypeR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"inline ~HTypeR()\n"})}),"\n",(0,s.jsx)(r.p,{children:"Decrements refcount, closing the node handle if this is the last reference."}),"\n",(0,s.jsx)(r.h3,{id:"raw",children:"raw"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"static inline T * raw(\r\n    const HTypeR< T > arr[]\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Converts an array of reference counted handles to an array of raw handles for passing to an api function that expects an array of handles. Return value is only valid until the next call to this function."}),"\n",(0,s.jsx)(r.h2,{id:"public-attributes-documentation",children:"Public Attributes Documentation"}),"\n",(0,s.jsx)(r.h3,{id:"m_handle",children:"m_handle"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"T m_handle;\n"})}),"\n",(0,s.jsx)(r.p,{children:"The handle to wrap."}),"\n",(0,s.jsx)(r.h3,{id:"ptr",children:"ptr"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"HRefCount * ptr;\n"})}),"\n",(0,s.jsx)(r.p,{children:"Reference counter. Automatically deletes itself when the refcount is zero."})]})}function o(e={}){const{wrapper:r}={...(0,c.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>l});var t=n(96540);const s={},c=t.createContext(s);function i(e){const r=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(c.Provider,{value:r},e.children)}}}]);