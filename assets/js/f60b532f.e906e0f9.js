"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[93185],{46727:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>n,metadata:()=>d,toc:()=>o});const d=JSON.parse('{"id":"visionary-render-programming/reference/c-api/classes/metanodes/meta-light","title":"Meta_Light","description":"Module: Metanodes / Definitions","source":"@site/docs/visionary-render-programming/reference/c-api/classes/metanodes/meta-light.mdx","sourceDirName":"visionary-render-programming/reference/c-api/classes/metanodes","slug":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-light","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-light","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/c-api/classes/metanodes/meta-light.mdx","tags":[],"version":"current","lastUpdatedAt":1730817102000,"frontMatter":{"title":"Meta_Light","summary":"A Light lights the scene. It is intended to be a child of a Meta_Assembly so it can be positioned in the scene."},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Meta_LightProbe","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-light-probe"},"next":{"title":"Meta_LOD","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-lod"}}');var i=s(74848),r=s(28453);const n={title:"Meta_Light",summary:"A Light lights the scene. It is intended to be a child of a Meta_Assembly so it can be positioned in the scene."},a="Meta_Light",h={},o=[{value:"Public Types",id:"public-types",level:2},{value:"Public Types Documentation",id:"public-types-documentation",level:2},{value:"enum IDX",id:"enum-idx",level:3},{value:"enum LIGHTTYPE",id:"enum-lighttype",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"meta_light",children:"Meta_Light"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Module:"})," ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/",children:"Metanodes"})})," ",(0,i.jsx)(t.strong,{children:"/"})," ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/definitions",children:"Definitions"})})]}),"\n",(0,i.jsxs)(t.p,{children:["A Light lights the scene. It is intended to be a child of a ",(0,i.jsx)(t.a,{href:"/visionary-render-programming/reference/c-api/classes/metanodes/meta-assembly",children:"Meta_Assembly"})," so it can be positioned in the scene."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"#include <meta_importables.hpp>"})}),"\n",(0,i.jsx)(t.h2,{id:"public-types",children:"Public Types"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Type"}),(0,i.jsx)(t.th,{children:"Name"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"enum"}),(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"#enum-idx",children:"IDX"})})," { Idx_Enabled, Idx_Type, Idx_Colour, Idx_Radius, Idx_SpotCone, Idx_ShadowMap, Idx_ShadowMapSize, Idx_ShadowClipOffset, Idx_Intensity, Idx_ShadowBlur, Idx_ShadowOverdarken, Idx_ShadowStrength, Idx_ShadowBoundsNode, Idx_Texture, Idx_AreaSize, Idx_InverseSquareFalloff, Idx_CascadedShadowMap, Idx_CascadedShadowMapSplits, Idx_CascadedShadowMapStaggered, Idx_MaxViewDistance, Idx_MaxViewDistanceFade, Idx_LockShadowMap }",(0,i.jsx)("br",{}),"Property index."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"enum"}),(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"#enum-lighttype",children:"LIGHTTYPE"})})," { LIGHTTYPE_DIR, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, LIGHTTYPE_AMBIENT, LIGHTTYPE_AREA }",(0,i.jsx)("br",{}),"Values for Idx_Type."]})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"public-types-documentation",children:"Public Types Documentation"}),"\n",(0,i.jsx)(t.h3,{id:"enum-idx",children:"enum IDX"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Enumerator"}),(0,i.jsx)(t.th,{children:"Value"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_Enabled"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"bool - Whether the light is enabled"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_Type"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"LIGHTTYPE (int) - Type of light"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_Colour"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"vec3f - Colour that this light emits"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_Radius"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"world_float - For Point and Spot types: The distance at which the light fades to 100% black. If zero, no fading will be applied"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_SpotCone"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"vec2f - For Spot type: X = cone cutoff angle (0-90 degrees), Y = cone intensity distribution exponent (0-128)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_ShadowMap"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"bool - For all types except Ambient: Cast shadows from visuals that have their shadow caster property enabled"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_ShadowMapSize"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"int - Resoltion of the shadow map texture"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_ShadowClipOffset"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"float - Offset of shadowmap near clip plane"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_Intensity"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"float - Scalar to apply to light colour when doing light calculation"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_ShadowBlur"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"int - The number of times to blur the shadowmap"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_ShadowOverdarken"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"float - How much to overdarken the shadow to compensate for light bleeding"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_ShadowStrength"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"float - How dark the shadow is, 0=no shadow, 1=jet black shadow"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_ShadowBoundsNode"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"link = If set, adjusts the shadow map for a directional light to include just this node instead of the whole scene"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_Texture"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"Unused."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_AreaSize"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"vec2f - For Area type: Size of the light surface"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_InverseSquareFalloff"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"bool - For Point and Spot types: Causes the light closest to its source to be very bright, getting dimmer very quickly as it moves to the radius bool - If true and this is a directional light then the renderer will use the view-dependent cascaded shadowmap method for shadows. This method is costly to the frame rate because all shadow casters in the scene are redrawn 4 times every frame, but give consistently high resolution shadows regardless of scene size and view position."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_CascadedShadowMap"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_CascadedShadowMapSplits"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"vec4w - These define the distances from the viewer where each of the 4 cascades ends. The smaller the value the more detailed the shadow in that cascade but the less area it covers in the world. Each distance is relative to the previous distance, except for the first which is relative to the near clip plane of whichever view is using the shadow map. e.g. if the values were 5,5,5,5 then the first cascade would cover an area from 0 to 5 metres from the near clip plane, the second cascade would cover from 5 metres to 10 metres, the third from 10 to 15 etc."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_CascadedShadowMapStaggered"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"bool - If true, only one split of the cascaded shadow map will be drawn per frame, cycling through to the next split each frame."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_MaxViewDistance"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"float - The maxmimum distance from the camera at which this light will be rendered, or zero if it should render at any distance."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_MaxViewDistanceFade"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"float - The proportion of MaxViewDistance over which the light fades out smoothly."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Idx_LockShadowMap"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"bool - if true the shadow map of the light will not be redrawn until it's set to false again"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Property index."}),"\n",(0,i.jsx)(t.h3,{id:"enum-lighttype",children:"enum LIGHTTYPE"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Enumerator"}),(0,i.jsx)(t.th,{children:"Value"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LIGHTTYPE_DIR"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["Directional light (Symbols - C: ",(0,i.jsx)(t.code,{children:'"TypeDirectional"'}),", Lua: ",(0,i.jsx)(t.code,{children:"__Light_TypeDirectional"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LIGHTTYPE_POINT"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["Point light (Symbols - C: ",(0,i.jsx)(t.code,{children:'"TypePoint"'}),", Lua: ",(0,i.jsx)(t.code,{children:"__Light_TypePoint"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LIGHTTYPE_SPOT"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["Spot light (Symbols - C: ",(0,i.jsx)(t.code,{children:'"TypeSpot"'}),", Lua: ",(0,i.jsx)(t.code,{children:"__Light_TypeSpot"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LIGHTTYPE_AMBIENT"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["Ambient light (Symbols - C: ",(0,i.jsx)(t.code,{children:'"TypeAmbient"'}),", Lua: ",(0,i.jsx)(t.code,{children:"__Light_TypeAmbient"}),")"]})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Values for Idx_Type."})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>a});var d=s(96540);const i={},r=d.createContext(i);function n(e){const t=d.useContext(r);return d.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:n(e.components),d.createElement(r.Provider,{value:t},e.children)}}}]);