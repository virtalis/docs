"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[14370],{56707:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>d,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"visionary-render-programming/reference/c-api/namespaces/vrtree-cpp","title":"vrtree_cpp","description":"Namespace containing a collection of helper functions for simplifying reading of C++ objects out of the C API (e.g. strings, etc)","source":"@site/docs/visionary-render-programming/reference/c-api/namespaces/vrtree-cpp.mdx","sourceDirName":"visionary-render-programming/reference/c-api/namespaces","slug":"/visionary-render-programming/reference/c-api/namespaces/vrtree-cpp","permalink":"/visionary-render-programming/reference/c-api/namespaces/vrtree-cpp","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/c-api/namespaces/vrtree-cpp.mdx","tags":[],"version":"current","lastUpdatedAt":1730817102000,"frontMatter":{"title":"vrtree_cpp","summary":"Namespace containing a collection of helper functions for simplifying reading of C++ objects out of the C API (e.g. strings, etc)"},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"VR Exchange","permalink":"/visionary-render-programming/reference/c-api/modules/vrexchange"},"next":{"title":"MULTI","permalink":"/visionary-render-programming/reference/lua-api/classes/multi"}}');var s=n(74848),i=n(28453);const d={title:"vrtree_cpp",summary:"Namespace containing a collection of helper functions for simplifying reading of C++ objects out of the C API (e.g. strings, etc)"},a="vrtree_cpp",c={},o=[{value:"Classes",id:"classes",level:2},{value:"Types",id:"types",level:2},{value:"Functions",id:"functions",level:2},{value:"Types Documentation",id:"types-documentation",level:2},{value:"typedef HFFIVarR",id:"typedef-hffivarr",level:3},{value:"typedef HMetaR",id:"typedef-hmetar",level:3},{value:"typedef HMigrationR",id:"typedef-hmigrationr",level:3},{value:"typedef HNodeR",id:"typedef-hnoder",level:3},{value:"Functions Documentation",id:"functions-documentation",level:2},{value:"getNodeName",id:"getnodename",level:3},{value:"getNodePath",id:"getnodepath",level:3},{value:"readStringProp",id:"readstringprop",level:3},{value:"readStringProp",id:"readstringprop-1",level:3},{value:"RegisterObserver",id:"registerobserver",level:3},{value:"UnRegisterObserver",id:"unregisterobserver",level:3}];function p(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"vrtree_cpp",children:"vrtree_cpp"})}),"\n",(0,s.jsx)(r.p,{children:"Namespace containing a collection of helper functions for simplifying reading of C++ objects out of the C API (e.g. strings, etc)"}),"\n",(0,s.jsx)(r.h2,{id:"classes",children:"Classes"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Name"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"struct"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-handle",children:"vrtree_cpp::Handle"})})," ",(0,s.jsx)("br",{}),"Helper struct to take any handle and close it appropriately."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"struct"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-hrefcount",children:"vrtree_cpp::HRefCount"})})," ",(0,s.jsx)("br",{}),"Helper structure that provides a reference count that persists between refcounted handle copies."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"struct"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper",children:"vrtree_cpp::HTypeR"})})," ",(0,s.jsx)("br",{}),"Reference counted wrapper around a handle. Automatically closes the handle when there are no references left."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"class"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-nodemanager",children:"vrtree_cpp::NodeManager"})})," ",(0,s.jsx)("br",{}),"Utility class providing an interface for responding to changes to specified metanodes; with an additional update function, which will be called every time a frame is drawn."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"struct"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-observerwrapper",children:"vrtree_cpp::ObserverWrapper"})})," ",(0,s.jsx)("br",{}),"Wraps a class implementing static observer functions accepting refcounted handles."]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"types",children:"Types"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Name"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:["typedef ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper",children:"HTypeR"}),"< ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hffivar",children:"HFFIVar"})," >"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#typedef-hffivarr",children:"HFFIVarR"})})," ",(0,s.jsx)("br",{}),"Reference counted FFI handle."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:["typedef ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper",children:"HTypeR"}),"< ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," >"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#typedef-hmetar",children:"HMetaR"})})," ",(0,s.jsx)("br",{}),"Reference counted metanode handle."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:["typedef ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper",children:"HTypeR"}),"< ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmigration",children:"HMigration"})," >"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#typedef-hmigrationr",children:"HMigrationR"})})," ",(0,s.jsx)("br",{}),"Reference counted migration handle."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:["typedef ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/classes/vrtree-cpp-htyper",children:"HTypeR"}),"< ",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," >"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#typedef-hnoder",children:"HNodeR"})})," ",(0,s.jsx)("br",{}),"Reference counted node handle."]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Name"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"std::string"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#getnodename",children:"getNodeName"})}),"(",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," node)",(0,s.jsx)("br",{}),"Utility function for getting the name of a node."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"std::string"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#getnodepath",children:"getNodePath"})}),"(",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," node)",(0,s.jsx)("br",{}),"Utility function for getting the path of a node."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"std::string"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#readstringprop",children:"readStringProp"})}),"(",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," node, const char * propName)",(0,s.jsx)("br",{}),"Utility function for reading a string property."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"std::string"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#readstringprop",children:"readStringProp"})}),"(",(0,s.jsx)(r.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hnode",children:"HNode"})," node, uint32_t prop)",(0,s.jsx)("br",{}),"Utility function for reading a string property."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:["template <typename T> ",(0,s.jsx)("br",{}),"void"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#registerobserver",children:"RegisterObserver"})}),"(const char * metaName)",(0,s.jsx)("br",{}),"Registers a class implementing static observer functions as an observer of the specified metanode."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:["template <typename T> ",(0,s.jsx)("br",{}),"void"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"#unregisterobserver",children:"UnRegisterObserver"})}),"(const char * metaName)",(0,s.jsx)("br",{}),"Unregisters a class implementing static observer functions as an observer of the specified metanode."]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"types-documentation",children:"Types Documentation"}),"\n",(0,s.jsx)(r.h3,{id:"typedef-hffivarr",children:"typedef HFFIVarR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"typedef HTypeR<HFFIVar> vrtree_cpp::HFFIVarR;\n"})}),"\n",(0,s.jsx)(r.p,{children:"Reference counted FFI handle."}),"\n",(0,s.jsx)(r.h3,{id:"typedef-hmetar",children:"typedef HMetaR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"typedef HTypeR<HMeta> vrtree_cpp::HMetaR;\n"})}),"\n",(0,s.jsx)(r.p,{children:"Reference counted metanode handle."}),"\n",(0,s.jsx)(r.h3,{id:"typedef-hmigrationr",children:"typedef HMigrationR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"typedef HTypeR<HMigration> vrtree_cpp::HMigrationR;\n"})}),"\n",(0,s.jsx)(r.p,{children:"Reference counted migration handle."}),"\n",(0,s.jsx)(r.h3,{id:"typedef-hnoder",children:"typedef HNodeR"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"typedef HTypeR<HNode> vrtree_cpp::HNodeR;\n"})}),"\n",(0,s.jsx)(r.p,{children:"Reference counted node handle."}),"\n",(0,s.jsx)(r.h2,{id:"functions-documentation",children:"Functions Documentation"}),"\n",(0,s.jsx)(r.h3,{id:"getnodename",children:"getNodeName"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"static std::string getNodeName(\r\n    HNode node\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Utility function for getting the name of a node."}),"\n",(0,s.jsx)(r.p,{children:"Uses an internal buffer to provide to the C API, and copies it into the returned std::string object."}),"\n",(0,s.jsx)(r.h3,{id:"getnodepath",children:"getNodePath"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"static std::string getNodePath(\r\n    HNode node\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Utility function for getting the path of a node."}),"\n",(0,s.jsx)(r.p,{children:"Uses an internal buffer to provide to the C API, and copies it into the returned std::string object."}),"\n",(0,s.jsx)(r.h3,{id:"readstringprop",children:"readStringProp"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"static std::string readStringProp(\r\n    HNode node,\r\n    const char * propName\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Utility function for reading a string property."}),"\n",(0,s.jsx)(r.p,{children:"Uses an internal buffer to provide to the C API, and copies it into the returned std::string object."}),"\n",(0,s.jsx)(r.h3,{id:"readstringprop-1",children:"readStringProp"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"static std::string readStringProp(\r\n    HNode node,\r\n    uint32_t prop\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Utility function for reading a string property."}),"\n",(0,s.jsx)(r.p,{children:"Uses an internal buffer to provide to the C API, and copies it into the returned std::string object."}),"\n",(0,s.jsx)(r.h3,{id:"registerobserver",children:"RegisterObserver"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"template <typename T>\r\nvoid RegisterObserver(\r\n    const char * metaName\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Registers a class implementing static observer functions as an observer of the specified metanode."}),"\n",(0,s.jsx)(r.h3,{id:"unregisterobserver",children:"UnRegisterObserver"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"template <typename T>\r\nvoid UnRegisterObserver(\r\n    const char * metaName\r\n)\n"})}),"\n",(0,s.jsx)(r.p,{children:"Unregisters a class implementing static observer functions as an observer of the specified metanode."})]})}function l(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>d,x:()=>a});var t=n(96540);const s={},i=t.createContext(s);function d(e){const r=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);