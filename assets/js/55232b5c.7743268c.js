"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[55988],{50040:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"visionary-render/scene/merging","title":"Merging","description":"Visionary Render permits you to merge an existing VRNative or VRText file into the current scene. There are two types of merge: basic and advanced. A basic merge simply merges a chosen scene into the root node with the current merge settings, whereas an advanced merge presents you with a Merge Settings dialog that can be used to analyse and configure the merge before it is performed.","source":"@site/docs/visionary-render/scene/merging.mdx","sourceDirName":"visionary-render/scene","slug":"/visionary-render/scene/merging","permalink":"/visionary-render/scene/merging","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render/scene/merging.mdx","tags":[],"version":"current","lastUpdatedAt":1741279868000,"frontMatter":{},"sidebar":"visionaryRenderSidebar","previous":{"title":"Media","permalink":"/visionary-render/scene/media"},"next":{"title":"Pivots","permalink":"/visionary-render/scene/pivots"}}');var i=n(74848),r=n(28453);const d={},o="Merging",a={},h=[{value:"Basic Merge",id:"basic-merge",level:2},{value:"Advanced Merge",id:"advanced-merge",level:2},{value:"Analyse",id:"analyse",level:3},{value:"Configure",id:"configure",level:3},{value:"Preset",id:"preset",level:4},{value:"Settings",id:"settings",level:4}];function l(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"merging",children:"Merging"})}),"\n",(0,i.jsxs)(t.p,{children:["Visionary Render permits you to merge an existing ",(0,i.jsx)(t.code,{children:"VRNative"})," or ",(0,i.jsx)(t.code,{children:"VRText"})," file into the current scene. There are two types of merge: basic and advanced. A basic merge simply merges a chosen scene into the root node with the current merge settings, whereas an advanced merge presents you with a Merge Settings dialog that can be used to analyse and configure the merge before it is performed."]}),"\n",(0,i.jsx)(t.h2,{id:"basic-merge",children:"Basic Merge"}),"\n",(0,i.jsxs)(t.p,{children:["To merge a file into your current scene, click on the Virtalis button at the top-left of the Toolbar and select ",(0,i.jsx)(t.strong,{children:"Import"})," > ",(0,i.jsx)(t.strong,{children:"Visionary Render Scene"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(30402).A+"",width:"634",height:"157"})}),"\n",(0,i.jsxs)(t.p,{children:["A file browser will be shown to enable you to select a ",(0,i.jsx)(t.code,{children:"VRNative"})," or ",(0,i.jsx)(t.code,{children:"VRText"})," file to merge into the current scene. Select a file and press the ",(0,i.jsx)(t.strong,{children:"OK"})," button to perform the merge."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(81680).A+"",width:"698",height:"498"})}),"\n",(0,i.jsx)(t.h2,{id:"advanced-merge",children:"Advanced Merge"}),"\n",(0,i.jsxs)(t.p,{children:["To perform an advanced merge, follow the same steps as above but click the ",(0,i.jsx)(t.strong,{children:"Show Settings"})," checkbox before pressing the ",(0,i.jsx)(t.strong,{children:"OK"})," button. The Merge Settings dialog will now be shown to permit the merge to be configured."]}),"\n",(0,i.jsx)(t.h3,{id:"analyse",children:"Analyse"}),"\n",(0,i.jsx)(t.p,{children:"The Analyse page permits the location of the merge to be configured and shows a preview of how the Libraries and Scenes trees will look following the merge."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(50310).A+"",width:"517",height:"515"})}),"\n",(0,i.jsx)(t.p,{children:"The Existing Root and Incoming Root properties are optional and can be used to specify where the merge should start from in the scene. An item in the tree view can also be dragged onto any node in the scene to automatically populate the roots from which to perform the merge. These properties can typically be left blank - in which case the merge uses the root of the current scene and the root of the incoming scene, respectively."}),"\n",(0,i.jsxs)(t.p,{children:["When done, press the ",(0,i.jsx)(t.strong,{children:"Analyse"})," button to analyse the merge. This performs a search on the tree, attempting to match parts of the incoming scene with objects in the current scene."]}),"\n",(0,i.jsx)(t.h3,{id:"configure",children:"Configure"}),"\n",(0,i.jsx)(t.p,{children:"The Configure page is displayed once the analysis is complete. It shows the results of the analysis and permits preset or custom merge options to be selected."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(73397).A+"",width:"516",height:"585"})}),"\n",(0,i.jsx)(t.h4,{id:"preset",children:"Preset"}),"\n",(0,i.jsx)(t.p,{children:"The Preset drop-down can be used to apply settings for some common merging tasks. It has 5 options:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"None"}),(0,i.jsxs)(t.td,{children:["Don\u2019t apply a preset. ",(0,i.jsx)(t.em,{children:"[default]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Merge Alongside Existing"}),(0,i.jsx)(t.td,{children:"Copy all the incoming data into the current scene without doing any checking for existing data. Nothing is overwritten, but this may result in duplicate data if some geometry or material exists in both the current scene and the incoming scene."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Library Merge"}),(0,i.jsx)(t.td,{children:"Merge the Libraries tree only. This can be useful to apply updates to geometry and materials without touching the transforms of any assemblies or otherwise affecting the PLM tree layout. This option will replace any existing library objects it finds when matching. Any libraries not in the existing scene will be added too. Libraries not in the incoming scene will not be deleted."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Existing Update Only"}),(0,i.jsx)(t.td,{children:"Only update the values of existing objects in the scene. If there are new objects in the scene, they will be ignored. The Analysis results will indicate the number of affected objects, where it specifies the number of existing nodes and the number of new branches. In this mode, the new branches will not be merged."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Full Merge"}),(0,i.jsx)(t.td,{children:"Perform a full merge, updating all existing values and adding all new branches."})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"settings",children:"Settings"}),"\n",(0,i.jsx)(t.p,{children:"If necessary, you can customise the merge with the following settings."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Setting"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Consolidate"}),(0,i.jsxs)(t.td,{children:["Bypasses most of the merging logic to insert the incoming data alongside any existing data in the scene. No existing nodes are updated, all data is added under a new Assembly and corresponding Library. If enabled, it does not duplicate the Scene node. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Archive"}),(0,i.jsxs)(t.td,{children:["(for Consolidate only) Enables the Archive property of the Library node created because of the consolidated merge. This means that all the merged data is saved out in a file specified by Archive Name. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Archive Name"}),(0,i.jsxs)(t.td,{children:["(for Consolidate only) The file name to use for the library archive. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Merge Libraries Only"}),(0,i.jsxs)(t.td,{children:["Merges only the contents of the Libraries tree in the incoming file. Does not touch the Scenes tree. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Merge Additions Only"}),(0,i.jsxs)(t.td,{children:["Ignores any property changes to existing nodes, and merges only those that do not already exist. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Ignore Additions"}),(0,i.jsxs)(t.td,{children:["Ignores any new nodes and only updates the properties of existing ones. This is ignored if Merge Additions Only is enabled. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Add to Parent"}),(0,i.jsxs)(t.td,{children:["Any new nodes are added as children of the existing one that is currently being updated \u2013 e.g. if existing Assembly has a child called Engine, and the incoming Assembly has a child called Wheels, Wheels will become a sibling of Engine. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Add to Branch"}),(0,i.jsxs)(t.td,{children:["Any new nodes are added as children of a new node, named after the incoming scene. This is like the behaviour of Consolidate except that it only applies to new nodes. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Pull Link Dependencies"}),(0,i.jsxs)(t.td,{children:["This should almost always be turned on, except when merging very specific parts of a scene, such as a user interface with script events on it. When merging non-root nodes (specified during analysis), any link properties that point to other nodes that may not be part of the selected incoming data tree have their targets merged into the scene too. Any links on those nodes have their targets merged recursively until all the dependencies are present in the main tree. This respects any types specified in the ignore list. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Ignore Nodes"}),(0,i.jsx)(t.td,{children:"These options ignore specific node types during the merge. Any other types can be specified in the Ignore Additional Types box, separated by commas. The names specified must match what is displayed in a node\u2019s properties window (e.g. \u201cAssembly\u201d). Note: during the update of existing nodes, ignoring a node type does not prevent the merge traversal continuing down its children. When the merge will result in property updates only, ignoring a node type will only prevent properties of that type from being updated. It will continue to update any descendants with same filter."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Create Merge Groups"}),(0,i.jsxs)(t.td,{children:["Any merged nodes, be they existing or new, will get added to a group named after the input file. This provides an easy way to select all the nodes affected by a merge operation after it is complete. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Disable Removed"}),(0,i.jsxs)(t.td,{children:["After merging, walk down the tree and disable any nodes that were not affected by this merge. Unaffected nodes are marked as such because they did not exist in the incoming merge tree. Note that a node much have an enabled property for this to do anything to it. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Delete Removed"}),(0,i.jsxs)(t.td,{children:["Does the same as disable, except that it deletes the nodes instead of disabling them. ",(0,i.jsx)(t.em,{children:"[default: false]"})]})]})]})]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"The Merge Settings dialog removes DocumentOnLoad events if a merge would result in them being somewhere other than a child of the Scenes node."})}),"\n",(0,i.jsx)(t.p,{children:"The default values for most of these settings can be edited from the Settings window under the Merging category. When you change a setting in the Merge Settings dialog, the default value for that setting will also be updated in the Settings window. The Settings window can be used to configure basic merges without having to open the Merge Settings dialog."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(59262).A+"",width:"750",height:"558"})})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},50310:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/analyse-d05bb23fede5e2cf6b2a91b39b24aaec.png"},30402:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/app-menu-967198093fa6ba96ccf980ad85d90ff5.png"},73397:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/configure-825bcb24ddce780ee7e8a6e802ecb8bc.png"},81680:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/file-browser-a8402ab30f27706fffe73717e82b8bd0.png"},59262:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/settings-97d0b8eeeae3fe99c4d8e1747be696f9.png"},28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function d(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);