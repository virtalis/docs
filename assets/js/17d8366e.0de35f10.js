"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[58419],{72204:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"visionary-render-programming/reference/c-api/modules/metanodes/index","title":"Metanodes","description":"Modules","source":"@site/docs/visionary-render-programming/reference/c-api/modules/metanodes/index.mdx","sourceDirName":"visionary-render-programming/reference/c-api/modules/metanodes","slug":"/visionary-render-programming/reference/c-api/modules/metanodes/","permalink":"/visionary-render-programming/reference/c-api/modules/metanodes/","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/c-api/modules/metanodes/index.mdx","tags":[],"version":"current","lastUpdatedAt":1730817102000,"frontMatter":{"title":"Metanodes","summary":"Functions for defining Metanodes."},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Types","permalink":"/visionary-render-programming/reference/c-api/definitions/types"},"next":{"title":"Definitions","permalink":"/visionary-render-programming/reference/c-api/modules/metanodes/definitions"}}');var s=r(74848),i=r(28453);const a={title:"Metanodes",summary:"Functions for defining Metanodes."},d="Metanodes",o={},l=[{value:"Modules",id:"modules",level:2},{value:"Functions",id:"functions",level:2},{value:"Functions Documentation",id:"functions-documentation",level:2},{value:"VRCheckMetaHandleValid",id:"vrcheckmetahandlevalid",level:3},{value:"VRCloseMetaHandle",id:"vrclosemetahandle",level:3},{value:"VRCopyMetaNode",id:"vrcopymetanode",level:3},{value:"VRCreateIntermediateMetaNodes",id:"vrcreateintermediatemetanodes",level:3},{value:"VRCreateMetaNode",id:"vrcreatemetanode",level:3},{value:"VRCreateMetaNodeEx",id:"vrcreatemetanodeex",level:3},{value:"VRCurrentMetaNodeVersion",id:"vrcurrentmetanodeversion",level:3},{value:"VRDeleteMetaNode",id:"vrdeletemetanode",level:3},{value:"VRFinishMetaNode",id:"vrfinishmetanode",level:3},{value:"VRFinishMetaNodeEx",id:"vrfinishmetanodeex",level:3},{value:"VRGetMetaNodeName",id:"vrgetmetanodename",level:3},{value:"VRGetMetaNodeNameLength",id:"vrgetmetanodenamelength",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"metanodes",children:"Metanodes"})}),"\n",(0,s.jsx)(n.h2,{id:"modules",children:"Modules"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsx)(n.th,{children:"Name"})})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/definitions",children:"Definitions"})})," ",(0,s.jsx)("br",{}),"Listing of metanode structures, describing their purpose and listing their property index and any other supplementary enumerations."]})}),(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/migrations",children:"Migrations"})})," ",(0,s.jsx)("br",{}),"Functions for defining metanode migrations."]})}),(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/properties",children:"Properties"})})," ",(0,s.jsx)("br",{}),"Functions for managing properties on metanodes."]})}),(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/semantics-and-hints",children:"Semantics and Hints"})})," ",(0,s.jsx)("br",{}),"Functions for adding semantics and hints."]})})]})]}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Name"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"char"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrcheckmetahandlevalid",children:"VRCheckMetaHandleValid"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," metaNode)",(0,s.jsx)("br",{}),"Checks if a metanode handle is valid (that is, pointing at a metanode and not closed)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"void"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrclosemetahandle",children:"VRCloseMetaHandle"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," metaNode)",(0,s.jsx)("br",{}),"Closes a handle to a metanode."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrcopymetanode",children:"VRCopyMetaNode"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," other, int versionIncrement)",(0,s.jsx)("br",{}),"Copies a metanode internally in the API (that is, makes a new one with the same properties but doesn't give it to vrtree) It does this so that a migration can then modify it before VRFinishMetaNode is called as usual to instantiate it properly."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrcreateintermediatemetanodes",children:"VRCreateIntermediateMetaNodes"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," start, ",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," end)",(0,s.jsx)("br",{}),"Performs migrations of a metanode to create all known versions between start and end."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrcreatemetanode",children:"VRCreateMetaNode"})}),"(const char * metaName)",(0,s.jsx)("br",{}),"Creates a metanode (a description of a node structure)."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrcreatemetanodeex",children:"VRCreateMetaNodeEx"})}),"(const char * metaName, uint32_t flags)",(0,s.jsx)("br",{}),"Creates a metanode (a description of a node structure) with additional flags."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"size_t"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrcurrentmetanodeversion",children:"VRCurrentMetaNodeVersion"})}),"(const char * metaName, char * buffer, size_t bufferSize)",(0,s.jsx)("br",{}),"Gets the name of the current version of the specified metanode."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrdeletemetanode",children:"VRDeleteMetaNode"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," metaNode)",(0,s.jsx)("br",{}),"Deletes a metanode. Can only be done if there are no instances of the metanode and the metanode structure has not been passed to vrtree."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrfinishmetanode",children:"VRFinishMetaNode"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," metaNode)",(0,s.jsx)("br",{}),"Finishes a metanode definition by passing it to VRTree."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrfinishmetanodeex",children:"VRFinishMetaNodeEx"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," metaNode)",(0,s.jsx)("br",{}),"Finishes a metanode definition by passing it to VRTree."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"size_t"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrgetmetanodename",children:"VRGetMetaNodeName"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," metaNode, char * buffer, size_t bufferLength)",(0,s.jsx)("br",{}),"Gets the name of a metanode."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"size_t"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"#vrgetmetanodenamelength",children:"VRGetMetaNodeNameLength"})}),"(",(0,s.jsx)(n.a,{href:"/visionary-render-programming/reference/c-api/definitions/types#typedef-hmeta",children:"HMeta"})," metaNode)",(0,s.jsx)("br",{}),"Gets the length of a metanode's name, plus 1 for the trailing null terminator."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"functions-documentation",children:"Functions Documentation"}),"\n",(0,s.jsx)(n.h3,{id:"vrcheckmetahandlevalid",children:"VRCheckMetaHandleValid"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"char VRCheckMetaHandleValid(\r\n    HMeta metaNode\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Checks if a metanode handle is valid (that is, pointing at a metanode and not closed)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaNode"})," handle to check"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": 0 if invalid, 1 if valid"]}),"\n",(0,s.jsx)(n.h3,{id:"vrclosemetahandle",children:"VRCloseMetaHandle"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void VRCloseMetaHandle(\r\n    HMeta metaNode\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Closes a handle to a metanode."}),"\n",(0,s.jsx)(n.h3,{id:"vrcopymetanode",children:"VRCopyMetaNode"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"HMeta VRCopyMetaNode(\r\n    HMeta other,\r\n    int versionIncrement\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Copies a metanode internally in the API (that is, makes a new one with the same properties but doesn't give it to vrtree) It does this so that a migration can then modify it before VRFinishMetaNode is called as usual to instantiate it properly."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"other"})," handle to the metanode to copy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"versionIncrement"})," automatically increments the version number by this much (negative for decrement)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": new metanode"]}),"\n",(0,s.jsx)(n.h3,{id:"vrcreateintermediatemetanodes",children:"VRCreateIntermediateMetaNodes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int VRCreateIntermediateMetaNodes(\r\n    HMeta start,\r\n    HMeta end\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Performs migrations of a metanode to create all known versions between start and end."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"start"})," handle to the metanode to use as the starting point for migrations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"end"})," handle to the metanode to migrate to (versions are created until this version, but does not create this version)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": int the number of intermediate metanodes that exist between the requested versions, or -1 on failure"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Uses the version of start to begin - if end is > start, up migrations are used, otherwise down migrations are used."]}),"\n",(0,s.jsx)(n.h3,{id:"vrcreatemetanode",children:"VRCreateMetaNode"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"HMeta VRCreateMetaNode(\r\n    const char * metaName\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a metanode (a description of a node structure)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaName"})," the name of the new metanode"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": a handle to the metanode, for use with other metanode functions"]}),"\n",(0,s.jsx)(n.p,{children:"Metanodes start at version 0, and their version is incremented by VRAddMigration."}),"\n",(0,s.jsx)(n.p,{children:"Once a metanode has been instantiated (by creating a Node of this type), no further modifications are allowed to its structure."}),"\n",(0,s.jsx)(n.h3,{id:"vrcreatemetanodeex",children:"VRCreateMetaNodeEx"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"HMeta VRCreateMetaNodeEx(\r\n    const char * metaName,\r\n    uint32_t flags\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a metanode (a description of a node structure) with additional flags."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaName"})," the name of the new metanode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"flags"})," the flags to apply"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": a handle to the metanode, for use with other metanode functions"]}),"\n",(0,s.jsx)(n.h3,{id:"vrcurrentmetanodeversion",children:"VRCurrentMetaNodeVersion"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"size_t VRCurrentMetaNodeVersion(\r\n    const char * metaName,\r\n    char * buffer,\r\n    size_t bufferSize\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Gets the name of the current version of the specified metanode."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaName"})," the name of the metanode (no version suffix)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"buffer"})," the variable to recieve the name of the current version of this metanode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"bufferSize"})," size of the output buffer"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": number of bytes written to outputBuffer"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": if buffer is null, function returns the required size of the buffer"]}),"\n",(0,s.jsx)(n.h3,{id:"vrdeletemetanode",children:"VRDeleteMetaNode"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int VRDeleteMetaNode(\r\n    HMeta metaNode\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Deletes a metanode. Can only be done if there are no instances of the metanode and the metanode structure has not been passed to vrtree."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaNode"})," handle to the metanode to delete"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": 0 on success. If successful, the handle is closed automatically"]}),"\n",(0,s.jsx)(n.h3,{id:"vrfinishmetanode",children:"VRFinishMetaNode"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int VRFinishMetaNode(\r\n    HMeta metaNode\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Finishes a metanode definition by passing it to VRTree."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaNode"})," handle to the metanode to finish. this handle is closed by this function"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": 0 on success"]}),"\n",(0,s.jsx)(n.p,{children:"At this point, modifications to the metanode can no longer be made because the total number of migrations is used to set the metanode version."}),"\n",(0,s.jsx)(n.h3,{id:"vrfinishmetanodeex",children:"VRFinishMetaNodeEx"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"HMeta VRFinishMetaNodeEx(\r\n    HMeta metaNode\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Finishes a metanode definition by passing it to VRTree."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaNode"})," handle to the metanode to finish. this handle is closed by this function"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": a new handle to the real metanode"]}),"\n",(0,s.jsx)(n.p,{children:"At this point, modifications to the metanode can no longer be made because the total number of migrations is used to set the metanode version."}),"\n",(0,s.jsx)(n.h3,{id:"vrgetmetanodename",children:"VRGetMetaNodeName"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"size_t VRGetMetaNodeName(\r\n    HMeta metaNode,\r\n    char * buffer,\r\n    size_t bufferLength\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Gets the name of a metanode."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaNode"})," handle to the metanode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"buffer"})," a buffer to receive the node name as a null terminated string"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"size"})," size of the buffer"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return"}),": the number of characters written to the buffer (including trailing null)"]}),"\n",(0,s.jsx)(n.h3,{id:"vrgetmetanodenamelength",children:"VRGetMetaNodeNameLength"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"size_t VRGetMetaNodeNameLength(\r\n    HMeta metaNode\r\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Gets the length of a metanode's name, plus 1 for the trailing null terminator."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"metaNode"})," handle to the metanode"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>d});var t=r(96540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);