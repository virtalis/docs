"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[1172],{18794:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"visionary-render-programming/reference/c-api/classes/metanodes/meta-precision","title":"Meta_Precision","description":"Module: Metanodes / Definitions","source":"@site/docs/visionary-render-programming/reference/c-api/classes/metanodes/meta-precision.mdx","sourceDirName":"visionary-render-programming/reference/c-api/classes/metanodes","slug":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-precision","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-precision","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/reference/c-api/classes/metanodes/meta-precision.mdx","tags":[],"version":"current","frontMatter":{"title":"Meta_Precision","summary":"A Precision represents the tolerance value used by importer formats to tessellate a surface. Use validitymask to check which values are set."},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Meta_PoseStateGuard","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-pose-state-guard"},"next":{"title":"Meta_PropSemanticsLink","permalink":"/visionary-render-programming/reference/c-api/classes/metanodes/meta-prop-semantics-link"}}');var n=r(74848),i=r(28453);const a={title:"Meta_Precision",summary:"A Precision represents the tolerance value used by importer formats to tessellate a surface. Use validitymask to check which values are set."},d="Meta_Precision",o={},c=[{value:"Public Types",id:"public-types",level:2},{value:"Public Types Documentation",id:"public-types-documentation",level:2},{value:"enum IDX",id:"enum-idx",level:3}];function l(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"meta_precision",children:"Meta_Precision"})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Module:"})," ",(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/",children:"Metanodes"})})," ",(0,n.jsx)(s.strong,{children:"/"})," ",(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"/visionary-render-programming/reference/c-api/modules/metanodes/definitions",children:"Definitions"})})]}),"\n",(0,n.jsx)(s.p,{children:"A Precision represents the tolerance value used by importer formats to tessellate a surface. Use validitymask to check which values are set."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.code,{children:"#include <meta_importables.hpp>"})}),"\n",(0,n.jsx)(s.h2,{id:"public-types",children:"Public Types"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Type"}),(0,n.jsx)(s.th,{children:"Name"})]})}),(0,n.jsx)(s.tbody,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"enum"}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.strong,{children:(0,n.jsx)(s.a,{href:"#enum-idx",children:"IDX"})})," { Idx_ValidityMask, Idx_Length, Idx_Angle, Idx_ChordHeight, Idx_EdgeLength, Idx_Thickness, Idx_Model, Idx_Face, Idx_Vector }",(0,n.jsx)("br",{}),"Property index."]})]})})]}),"\n",(0,n.jsx)(s.h2,{id:"public-types-documentation",children:"Public Types Documentation"}),"\n",(0,n.jsx)(s.h3,{id:"enum-idx",children:"enum IDX"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Enumerator"}),(0,n.jsx)(s.th,{children:"Value"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_ValidityMask"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"bitfield indicating which properties are valid"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Length"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x1 Tolerance value for cleaning and is used to ensure that extra vertices are not created too close to existing vertices."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Angle"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x2 Angular Tolerance is the maximum angular deviation allowed between an analytical surface and its triangulation. Pairs of triangles cannot incorporate a dihedral angle greater than this amount. These units are expressed in degrees. This setting determines the minimum number of faces that may represent the circumference of a true cylinder, regardless of the Chord Height Tolerance setting. Medium and small objects relative to the total scene bounding box may easily fall within surface tolerance tessellation tolerances with perhaps only four or five sides representing a true cylindrical surface. Therefore, by using this tolerance setting you are controlling the \u201ccoarseness\u201d of tessellation regardless of the geometry\u2019s relative size in the scene. For example, an angle of 30 results in a 12 sided tessellated cylinder, and an angle of 45 results in an 8 sided tessellated cylinder."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_ChordHeight"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x4 Chord height tolerance is the value that is allowed between a surface described by the BREPs (boundary representations), and the polygons that are produced by the tessellation process to approximate that surface. That is, between an edge and its tessellation. A smaller chord height tolerance causes more polygons to be produced, creating smoother models. The units are expressed as unit size based on those used by the model."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_EdgeLength"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x8"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Thickness"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x10"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Model"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x20"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Face"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x40"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Idx_Vector"}),(0,n.jsx)(s.td,{}),(0,n.jsx)(s.td,{children:"0x80"})]})]})]}),"\n",(0,n.jsx)(s.p,{children:"Property index."})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>d});var t=r(96540);const n={},i=t.createContext(n);function a(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);