"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[1798],{40789:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"visionary-render-programming/plugins/advanced/metanode-versioning","title":"Metanode Versioning","description":"Metanodes describe the data structure used to represent nodes in the tree. Over time, the software evolves and new properties can be added, old properties removed, and the meaning of properties can change. In order to maintain maximum compatibility between different versions of Visionary Render, metanodes that undergo change can define migrations that describe the nature of that change, allowing a version of the software to be able to translate data into a format understandable by a different (usually older) version.","source":"@site/docs/visionary-render-programming/plugins/advanced/metanode-versioning.mdx","sourceDirName":"visionary-render-programming/plugins/advanced","slug":"/visionary-render-programming/plugins/advanced/metanode-versioning","permalink":"/visionary-render-programming/plugins/advanced/metanode-versioning","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/plugins/advanced/metanode-versioning.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Coroutines in Lua Plugins","permalink":"/visionary-render-programming/plugins/advanced/lua-coroutines"},"next":{"title":"Semantics","permalink":"/visionary-render-programming/plugins/advanced/semantics"}}');var t=i(74848),o=i(28453);const a={},s="Metanode Versioning",d={},c=[{value:"Version Specification",id:"version-specification",level:2},{value:"Versioned vs. Unversioned Metanode Names",id:"versioned-vs-unversioned-metanode-names",level:2},{value:"Migrations",id:"migrations",level:2},{value:"Simple Migration",id:"simple-migration",level:3},{value:"Complex Migration",id:"complex-migration",level:3}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"metanode-versioning",children:"Metanode Versioning"})}),"\n",(0,t.jsx)(n.p,{children:"Metanodes describe the data structure used to represent nodes in the tree. Over time, the software evolves and new properties can be added, old properties removed, and the meaning of properties can change. In order to maintain maximum compatibility between different versions of Visionary Render, metanodes that undergo change can define migrations that describe the nature of that change, allowing a version of the software to be able to translate data into a format understandable by a different (usually older) version."}),"\n",(0,t.jsx)(n.p,{children:"We refer to this as cross-compatibility, using terms such as backward-compatible and forward-compatible."}),"\n",(0,t.jsxs)(n.p,{children:["Visionary Render is considered ",(0,t.jsx)(n.em,{children:"backward-compatible"})," when it is able to use data from previous versions, which is achieved through the implementation of migrations. It is considered ",(0,t.jsx)(n.em,{children:"forward-compatible"})," to an extent by virtue of the VRText/VRNative file format, which uses XML descriptions of nodes allowing older versions of Visionary Render to load newer scenes, limited by the older version's understanding of the node properties saved in the file."]}),"\n",(0,t.jsx)(n.h2,{id:"version-specification",children:"Version Specification"}),"\n",(0,t.jsxs)(n.p,{children:["Metanodes are given version numbers when their version exceeds ",(0,t.jsx)(n.code,{children:"0"}),'. These version numbers are appended to the name of the metanode. A metanode without a version number is considered the "base" version from which future versions are derived. It is up to the code that defines the metanode to append the version number.']}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Assembly.1"})," (a version 1 Assembly)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Collision"}),"  (a version 0 Collision)"]}),"\n",(0,t.jsx)(n.p,{children:"Version numbers are validated against the number of migrations that are registered against the metanode. For every version increment, there must be a corresponding migration implemented and registered."}),"\n",(0,t.jsx)(n.h2,{id:"versioned-vs-unversioned-metanode-names",children:"Versioned vs. Unversioned Metanode Names"}),"\n",(0,t.jsx)(n.p,{children:"When working with API functions, either directly with the C API or via Lua, it is important to understand the difference between versioned and unversioned metanode names."}),"\n",(0,t.jsx)(n.p,{children:'Metanode versions are suffixed to the end of the name, creating what we refer to as the "Versioned" metanode name. This is the name that is reported when using any functions that query the name of a metanode or a type of node instance.'}),"\n",(0,t.jsx)(n.p,{children:'"Unversioned" names are the metanode names without the version suffix.'}),"\n",(0,t.jsx)(n.p,{children:"The Lua API functions that accept metanode name parameters can accept either versioned or unversioned names."}),"\n",(0,t.jsxs)(n.p,{children:["The C API functions that accept metanode names expect versioned names, with the exception of ",(0,t.jsx)(n.code,{children:"VRCurrentMetaNodeVersion"}),', which takes an unversioned name and returns the versioned name of the "current" metanode (that is, the version defined outside of any migrations).']}),"\n",(0,t.jsx)(n.h2,{id:"migrations",children:"Migrations"}),"\n",(0,t.jsxs)(n.p,{children:["When a metanode version exceeds ",(0,t.jsx)(n.code,{children:"0"}),", migrations are required."]}),"\n",(0,t.jsx)(n.p,{children:"Some migrations are simple. Others are complicated. Their complexity depends on the nature of the upgrade."}),"\n",(0,t.jsx)(n.p,{children:"Each migration can consist of up to 4 functions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Up"})," for upgrading the metanode definition to the next version"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Down"})," for downgrading the metanode definition to the previous version"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Upgrade"})," for upgrading node instance properties to the next version of the metanode"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Downgrade"})," for downgrading node instance properties to the previous version of the metanode"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For the simplest case of simply adding or removing a property with no side-effects, only the ",(0,t.jsx)(n.code,{children:"Up"})," and ",(0,t.jsx)(n.code,{children:"Down"})," functions are required. The node instances are migrated automatically in this case because there are no specific property value changes required."]}),"\n",(0,t.jsx)(n.h3,{id:"simple-migration",children:"Simple Migration"}),"\n",(0,t.jsxs)(n.p,{children:["Given this example metanode definition (using the ",(0,t.jsx)(n.code,{children:"vrtree-linker"})," C macros):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'struct Meta_MyMetaNode {\r\n  VR_META_METHODS("MyMetaNode");\r\n  static void Register() {\r\n    HMeta metaNode = VRCreateMetaNode(Name());\r\n    VRFinishMetaNode(metaNode);\r\n  }\r\n};\n'})}),"\n",(0,t.jsx)(n.p,{children:"This metanode currently has no properties and no migrations. If we want to add a Position property, we add it to the definition along with a migration registration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'struct Meta_MyMetaNode {\r\n  VR_META_METHODS("MyMetaNode.1"); //we append a version number starting at 1\r\n  \r\n  enum { Idx_Position }; //we added this convenience enum for property indexing\r\n  \r\n  static void Register() {\r\n    HMeta metaNode = VRCreateMetaNode(Name());\r\n    \r\n    VRAddPropertyVec3f(metaNode, "Position", 0, 0, 0); //we added this property definition\r\n    \r\n    //register our migration for this change\r\n    VRAddMigration(metaNode, &Meta_MyMetaNode::MigrateAddPosition::reg);\r\n    \r\n    VRFinishMetaNode(metaNode);\r\n  }\r\n  \r\n  //implementing the migration inline for example convenience\r\n  struct MigrateAddPosition {\r\n    static int up(HMigration m, HMeta meta) {\r\n      //we make the same changes here that we just made to the definition\r\n      return VRAddPropertyVec3f(meta, "Position", 0, 0, 0);\r\n    }\r\n    static int down(HMigration m, HMeta meta) {\r\n      //to downgrade our property addition, we remove it instead\r\n      return VRRemoveProperty(meta, "Position");\r\n    }\r\n    static int reg(HMigration m) {\r\n      //this function is called when the metanode is ready to register migrations, so now we give it the functions we implemented above\r\n      VRSetMigrationUp(m, &up);\r\n      VRSetMigrationDown(m, &down);\r\n    }\r\n  };\r\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"complex-migration",children:"Complex Migration"}),"\n",(0,t.jsxs)(n.p,{children:["When a migration requires changes to values on node instances, the ",(0,t.jsx)(n.code,{children:"Upgrade"})," and ",(0,t.jsx)(n.code,{children:"Downgrade"})," functions are required, meaning the default implementation to migrate simple changes no longer applies."]}),"\n",(0,t.jsx)(n.p,{children:"In most cases, the majority of the default logic is still required - you just want to change the value of one of the properties and leave the rest alone. For this, the boilerplate is as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'static HNode upgrade(HMigration m, HNode old)\r\n{\r\n  // Trigger the previous migration in the chain.\r\n  // This ensures that the old node is at the version we expect in this migration.\r\n  // We can also manually seek back through the chain and apply any migration we wish,\r\n  // if, for some reason, we need to perform a direct migration from a specific version.\r\n  old = VRMigrationPrepareNode(m, old);\r\n  // Create a node at this version, as a sibling of the old node, so tree order is preserved when old is deleted.\r\n  HNode newNode = VRMigrationCreateCurrentNode(m, old);                                                            \r\n  // This is a mostly trivial migration, so most known properties can be copied directly\r\n  VRMigrationCopyKnownProperties(m, old, newNode);\r\n  \r\n  // -----------------------------------------\r\n  // This is where you would perform your own upgrade logic.\r\n  // -----------------------------------------\r\n  // For our example metanode above, we can do something trivial such as looking for a child node to copy a value from\r\n  if(vrtree_cpp::HNodeR child = VRFindChildPooled(old, "MetaDataFloat3", "Position")) {\r\n    float vec[3];\r\n    VRGetPropertyValue(child, "Value", vec, sizeof(vec));\r\n    VRSetPropertyValue(newNode, "Position", vec, sizeof(vec));\r\n    VRDeleteNode(child);\r\n  }\r\n  // -----------------------------------------\r\n    \r\n  // We are done with this migration, so finish it, cleaning up the old node\r\n  VRMigrationFinish(m, old, newNode);\r\n  // Return the new node, so the caller (or another migration) may continue to operate on it\r\n  return newNode;\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This function (and its corresponding downgrade, which uses identical boilerplate) should be registered in the same way as our ",(0,t.jsx)(n.code,{children:"Up"})," and ",(0,t.jsx)(n.code,{children:"Down"})," functions, except using ",(0,t.jsx)(n.code,{children:"VRSetMigrationUpgradeNode"})," and ",(0,t.jsx)(n.code,{children:"VRSetMigrationDowngradeNode"})]})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var r=i(96540);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);