"use strict";(self.webpackChunkvirtalis_docs=self.webpackChunkvirtalis_docs||[]).push([[9412],{30455:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"visionary-render-programming/plugins/introduction","title":"Introduction","description":"Plugins permit you to extend the functionality of Visionary Render in a way that persists across different scenes. The Plugin API is an extension to the core Visionary Render scripting capabilities. It provides documentation and helper libraries for the purpose of interacting natively with the C API.","source":"@site/docs/visionary-render-programming/plugins/introduction.mdx","sourceDirName":"visionary-render-programming/plugins","slug":"/visionary-render-programming/plugins/introduction","permalink":"/visionary-render-programming/plugins/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/virtalis/docs/tree/master/docs/visionary-render-programming/plugins/introduction.mdx","tags":[],"version":"current","lastUpdatedAt":1742560525000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"visionaryRenderProgrammingSidebar","previous":{"title":"Terminating Long Scripts","permalink":"/visionary-render-programming/scripts/advanced/terminating-long-scripts"},"next":{"title":"Best Practices","permalink":"/visionary-render-programming/plugins/best-practices"}}');var r=i(74848),s=i(28453);const a={sidebar_position:1},o="Introduction",d={},l=[{value:"Lua Plugins",id:"lua-plugins",level:2},{value:"Native Plugins",id:"native-plugins",level:2}];function c(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,r.jsx)(n.p,{children:"Plugins permit you to extend the functionality of Visionary Render in a way that persists across different scenes. The Plugin API is an extension to the core Visionary Render scripting capabilities. It provides documentation and helper libraries for the purpose of interacting natively with the C API."}),"\n",(0,r.jsx)(n.p,{children:"The SDK examples and helpers are written with C++ in mind, but the C API can be used by any language that is capable of invoking dynamic library functions. The one condition is that you must be able to create a binary that exports the required Plugin API functions. There are two kinds of plugin: Lua and Native."}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["For inspiration, see the ",(0,r.jsx)(n.a,{href:"https://github.com/virtalis",children:"Virtalis GitHub"})," for some example plugins."]})}),"\n",(0,r.jsx)(n.h2,{id:"lua-plugins",children:"Lua Plugins"}),"\n",(0,r.jsx)(n.p,{children:"A Lua plugin is a script that defines a module and a few simple identifying functions. Lua plugins are loaded into the Visionary Render scripting environment. This means that any scripts running on Event nodes or in the Console can use the functions defined by the plugin. Lua plugins can be developed with a standard installation of Visionary Render - there are no external libraries required."}),"\n",(0,r.jsx)(n.h2,{id:"native-plugins",children:"Native Plugins"}),"\n",(0,r.jsx)(n.p,{children:"A native plugin runs compiled code natively as part of the execution of the host application (i.e. Visionary Render). By contrast, a Lua script runs inside the Lua script engine. Native plugins benefit from faster execution so should be used for more intensive tasks."}),"\n",(0,r.jsx)(n.p,{children:"The executable code is compiled into a dynamic link library (DLL) and loaded at runtime by the plugin manager. A native plugin must export various entry points to allow the host to identify it and permit it to access the VRTree API."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);